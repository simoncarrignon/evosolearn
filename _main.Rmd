--- 
title: "Exploration model Evolution of Social Learning"
author: ""
date: "2020"
site: bookdown::bookdown_site
output:
  bookdown::gitbook: 
    nature:
      highlightStyle: github
documentclass: book
biblio-style: apalike
link-citations: yes
---

# Intro

tryign to centralized all exploration/observation here


\tableofcontents

```{r setup, include=FALSE}
library(magrittr)
library(scales)
knitr::opts_chunk$set(collapse=TRUE)
```

```{r write-bib, include=FALSE}
knitr::write_bib(c(.packages(), 'bookdown','tidyverse'), 'packages.bib')
```





<!--chapter:end:index.Rmd-->

# Explore environment function and properties

```{r echo=FALSE, message=FALSE}
knitr::opts_chunk$set(warning=FALSE,message=FALSE,out.width='100%',echo=TRUE)
source("tools.R")
source("protomodels.R")
source("toolsSummariesAndTraj.R")
source("environment.R")
```

## Check color of noise: 

Quic exploration of function used to generate $\frac{1}{f}$-noise:

```{r slope,fig.cap="noise generator"}
par(mfrow=c(3,2))
t=1000 #number of timestep
par(mfrow=c(3,2),mar=c(2,2,1,1))
for(alpha in 0:2){ #alpha as used in YK95 as our $\omega$
    ts=TK95(t,alpha) #generate random noise following Timmer & Koenig (1995) implemented in tuner package(https://rdrr.io/cran/tuner/src/r/waveforms.r)
    plot(ts,type="l") #plot the environment
    y=getSpectrum(ts) #get spectrum of the environment generated
    x=1:length(y)
    plot(log(x),log(y))
    fit=lm(log(y)~log(x),cbind.data.frame(x=1:length(y),y=y)) #fit a linear model to check slope
    abline(fit,col="red") #visualise the fit and coefficient computed
    text(1,max(log(y)),paste("coef=",abs(round(fit$coefficients[2],2))),col="red")
}
```

## Check $\delta$ (variance) of noise

```{r ,fig.cap="enrivonment generator"}
par(mfrow=c(3,2))
t=1000 #number of timestep
par(mfrow=c(3,2),mar=c(2,2,1,1))
for(omega in 0:2){ 
    ts=environment(t,omega=omega,delta=0.1)
    plot(ts,type="l") #plot the environment
    y=getSpectrum(ts) #get spectrum of the environment generated
    x=1:length(y)
    plot(log(x),log(y))
    fit=lm(log(y)~log(x),cbind.data.frame(x=1:length(y),y=y)) #fit a linear model to check slope
    abline(fit,col="red") #visualise the fit and coefficient computed
    text(1,max(log(y)),paste("coef=",abs(round(fit$coefficients[2],2))),col="red")
}
```


## Check auto-correlation

Using the same function we can have different level of auto-correlation 

```{r cov,fig.cap="autocorrelation"}
    par(mfrow=c(1,3))

    for(omega in 0:2){
        t=environment(50000,omega,.1)
        vtm=t[1:(length(t)-1)]
        vt=t[2:length(t)]
        print(cov(vt,vtm))
        cv=round(cov(vt,vtm),digit=3)
        plot((1:50000)[seq(1,50000,100)],t[seq(1,50000,100)],main=bquote(omega == .(omega)~","~delta==.1~", cov("*theta[t]*","*theta[t-1]*")" == .(cv)),ylab=bquote(theta[t]),,xlab="t",type="l",lwd=1)
    }

```


<!--chapter:end:01_environment.Rmd-->

# Exploring code speed


## How execution time scales

### Carrying capacity
```{r,echo=F}
doit=FALSE
```
```{r,eval=!doit}
load("data/allstr.bin")
load("data/allstr_tstep.bin")
```


Testing how execution time  change  when K increase when no social learn vs random selection vs best selection:
General parameters:
```{r}
strategies=c("best","random")
names(strategies)=strategies
colsstrategies=c("red","blue")
names(colsstrategies)=strategies
Ks=c(100,500,1000,2000,5000,10000)
tstep=5000
n=300
o=0 #omega
d=1 #delta
m=c(x=.1,y=.1,z=.1)
mu=c(x=.001,y=0.001,z=0.001)
E=c(x=0,y=0,z=0)
sigma=c(s=1000,y=10,z=10)
tsteps=c(100,1000,5000,10000)
```

```{r,eval=doit}
library(microbenchmark)
pop=generatePop(n,distrib=list(x=runif(n,-1,1),y=runif(n),z=runif(n)),df=F)

allstr=lapply( strategies,function(strat)
              {
                  timings=lapply(Ks,function(k)
								 {
									 print(k)
									 microbenchmark(
													simpleEvoModel(
																   n=n,
																   tstep=tstep,
																   omega = o,
																   delta = d ,
																   b=2,
																   K=k,
																   m=m,
																   mu=mu,
																   E=E,
																   sigma=sigma,
																   sls=strat,
																   pop=pop,
																   outputrate=1000,log=T
																   ),
													times=5,
													unit="s")
									 
								 })
                  print(strat)
                  sapply(timings,function(i)mean(i[,"time"]))
              }
)

#save(file="data/allstr.bin",allstr)
```


```{r profileKs,fig.cap="Executation time for differente carrying capacities"}
plot(Ks,allstr$best/10000000000,col="red",type="l",ylab="Execution time (in second)",xlab="K")
lines(Ks,allstr$random/10000000000,col="blue",type="l")
legend("topleft",legend=strategies,lty=1,col=colsstrategies)
```

### Number of time step 

Looking at the nubmer of timestep:

```{r,eval=doit}
k=1000

pop=generatePop(n,distrib=list(x=runif(n,-1,1),y=runif(n),z=runif(n)),df=F)

allstr_tstep=lapply( strategies,function(strat)
              {
                  timings=lapply(tsteps,function(tstep)
                                 microbenchmark(
                                                simpleEvoModel(
                                                               n=n,
                                                               tstep=tstep,
                                                               omega = o,
                                                               delta = d ,
                                                               b=2,
                                                               K=k,
                                                               m=m,
                                                               mu=mu,
                                                               E=E,
                                                               sigma=sigma,
                                                               sls=strat,
                                                               pop=pop,
                                                               outputrate=1,log=F
                                                               ),
                                                times=5,
                                                unit="s")
                                 )
                  print(strat)
                  sapply(timings,function(i)mean(i[,"time"]))
              }
)
#save(file="data/allstr_tstep.bin",allstr_tstep)
```

```{r profileTstep,fig.cap="Executation time for different number of tstep"}
plot(tsteps,allstr_tstep$best/10000000000,col="red",type="l",ylab="Execution time (in second)",xlab="time step")
lines(tsteps,allstr_tstep$random/10000000000,col="blue",type="l")
legend("topleft",legend=strategies,lty=1,col=colsstrategies)
```

## Profiling function calls

Profiling the model using `Rprof`:


```{r}
n=1000
pop=generatePop(n,distrib=list(x=runif(n,-1,1),y=rep(0,n),z=rep(0,n)),df=F)
tstep=1000
theta=environment(tstep,omega,.1,0)

par(mfrow=c(2,1))
for(strat in strategies){
df <- "test.log"
Rprof(df, memory.profiling = TRUE)
evodf=simpleEvoModel(n,tstep,omega = 0,delta = 0 ,b=2,K=1000,m=,mu=mu,E=E,sigma=sigma,log=F,sls=strat,theta=theta,pop=pop)
plot(evodf[,"mean_x"],type="l",ylab="mean_x",main=paste("strategie:",strat))
plot(evodf[,"mean_y"],type="l",col="green",ylim=c(0,1))
lines(evodf[,"mean_z"],type="l",col="orange")
legend("topleft",legend=c("mean_y","mean_z"),lty=1,col=c("green","orange"))
Rprof(NULL) ; 
sdf=summaryRprof(df)
rmarkdown::paged_table(as.data.frame(evodf))
}
```

<!--chapter:end:02_profiling.Rmd-->


# Explore genetic evolution only: 

```{r echo=FALSE, message=FALSE}

do_it=FALSE

#save(file="data/constant_env.bin",constant_env)
#save(file="data/v.bin",v)
#save(file="data/noisy_env.bin",noisy_env)
#save(file="data/noisy_env_omega",noisy_env_omega)
#save(file="data/moving_theta",moving_theta)
#save(file="data/omega1.bin",omega1)
#save(file="data/omega2.bin",omega2)
#save(file="data/allStatics.bin",allStatics)

#load(file="data/constant_env.bin")
#load(file="data/v.bin")
#load(file="data/noisy_env.bin")
#load(file="data/noisy_env_omega")
#load(file="data/omega1.bin")
#load(file="data/omega2.bin")
#load(file="data/moving_theta")
load(file="data/allStatics.bin")

```


## Constant Environment

Fixed parameter:
```{r}
n=1000
b=2
tstep=50000
mu=c(x=0,y=0,z=0)
E=c(x=0,y=0,z=0)
m=c(x=0,y=0,z=0)
sigma=c(s=1,y=1,z=1)
```
Explored parameters:
```{r}
allparameters=list()
allparameters[["mu"]]=c(0.001,0.01)
allparameters[["K"]]=c(500,1000,2000)
allparameters[["E"]]=0 #no noise
allparameters[["m"]]=c(.05,.1,.2)
allparameters[["sigma"]]=c(1,2,4,10000)
allparameters[["delta"]]=c(0,.1,.2,.4,1)
allparameters[["vt"]]=0 #no rate of change
allparameters[["omega"]]=c(0,2)
allparameters[["outputrate"]]=100
parameters=as.data.frame(expand.grid(allparameters))
```

```{r,echo=F}
rmarkdown::paged_table(parameters)
```




```{r,eval=do_it}
allStatics=getAlllSummaries("allWithNotMovingTheta/")
allStatics=updateScale(allStatics)
```

```{r}
constant_env=allStatics[allStatics$delta == 0,] 
```



### Trajectories

Check the trajectories of the simulation for the population size for different mutation rate $\mu$(from left to right: $\mu = 0, \mu = 0.001,\mu=0.01$), different selective pressure $\sigma_s$ (from top to bottomright: $\sigma_s = 0.1, \sigma_smu = 0.2,\sigma_s=0.4,\sigma_s=1000$) and  different carrying capacity $K$ 


```{r,fig.fullwidth=T,fig.height=10,fig.cap="Effective population size"}
#pdf("trajectory_N_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="N")
#dev.off()
```
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Variance"}
#pdf("trajectory_var_x_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="var_x",ylim=c(0,.02))
#dev.off()
```

### Variance at equilibrium

Check the variance at the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_x_const.pdf",width=12,height=16)
plotAllVariableSummaries(constant_env,E=0,estimate=eq2833b) #we use only simulations without noise
#dev.off()
```



## Constant but noisy environment
we use different  $\delta$  to generate environment with noise of growing variance

### Environment

```{r,fig.width=10,fig.height=5,fig.cap="effect of $\\delta$ on environment"}
d=c(0.00,0.01,0.10,0.20,0.40,1.00,10.00)
cols=colorRampPalette(c("black","grey"))(length(d))
names(cols)=d
omegas=1:2

plot(1,1,xlim=c(1,500),ylim=c(-10,10),type="n",xlab="t",ylab=expression(theta[t]))
for ( i in rev(d))
    lines(1:500,environment(500,omega=0,delta=i),col=cols[as.character(i)])
legend("topleft",legend=paste0("d=",d),col=cols,lty=1,bg="white")
```

To explore this we used the following parameters space:


```{r}
noisy_env = allStatics[allStatics$omega ==0,]
```


### Trajectories 

Check the trajectory off  the effective population size:
```{r,fig.width=20,fig.height=20}
#pdf("trajectory_N_noise.pdf",width=12,height=16)
plotAllTrajVar(noisy_env,m=0.05,E=0,obs="N")
#dev.off()
```

Check the trajectory off the mean variance:
```{r,fig.width=15,fig.height=10,fig.cap="Trajectory of Variance for noisy environment"}
#pdf("trajectory_var_x_noise.pdf",width=12,height=16)
plotAllTrajVar(noisy_env,m=0.05,E=0,obs="var_x",ylim=c(0,.03))
#dev.off()
```

### Variance at equilibrium

Check and compare the final variance :

```{r,fig.fullwidth=T,fig.height=10}
#pdf("equilibrium_var_x_noise.pdf",width=12,height=16)
plotAllVariableSummaries(noisy_env,E=0,estimate=eq2833b) 
#dev.off()
```



### Extinctions
Some of the data seems to be missing because when $\delta>\sigma$  we have extinctions, has shown in the Figure \@ref(fig:extinctionNoisy). 


```{r extinctionNoisy,warning=FALSE}
#pdf
sigmas=unique(noisy_env$sigma)
cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
names(cols)=sigmas
tmpc=noisy_env[ noisy_env$mu == 0.01 & noisy_env$m == 0.2 ,]
plot(tmpc$delta,tmpc$extinction,log="xy",type="n",ylab="extinction time",xlab=expression(delta),main=bquote(mu == 0.01 ~ omega == 0))
for(s in sigmas){
    tmpc=noisy_env[ noisy_env$sigma==s & noisy_env$mu == 0.01 & noisy_env$m == 0.2 ,]
    Ks=sort(unique(tmpc$K))
    for(k in 1:length(Ks)){
        t=tmpc[tmpc$K==Ks[k],]
        r=tapply(t$extinction,t$delta,mean)
        lines(sort(unique(t$delta)),r,type="b",pch=k,col=cols[as.character(s)])
    }
}
legend("right",
       legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
       col=c(rep(1,length(Ks)),cols),
       lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
       pch=c(seq_along(Ks),rep(NA,length(sigmas)))
       )
#dev.off()
```


## Constant, noisy, with autocorrelation

To avoid some of the exctinctions we introduction autocorrelation in the environment


### Environment
To introduce autocorrelation we increase slightly $omega$ which gives environment like the one below.


```{r}
par(mfrow=c(1,3))
plot(1:500,environment(500,omega=1,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==1))
plot(1:500,environment(500,omega=2,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==2))
plot(1:500,environment(500,omega=3,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==4))
```


For this we re-run previous experiment but with $\omega \in {1,2}$

```{r}
noisy_env_omega = allStatics
omega2 = allStatics[ allStatics$omega==2,]
```


### Extinctions

Let's look at the extinctions again now that we have the different omegas


```{r,fig.width=10,out.width='100%',fig.cap="Extinction wrt to deltas for different omegas"}
par(mfrow=c(1,2))
omegas=unique(noisy_env_omega$omega)
sigmas=sort(unique(noisy_env_omega$sigma))
deltas=sort(unique(noisy_env_omega$delta))
Ks=sort(unique(noisy_env_omega$K))
for(o in omegas){
    cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
    names(cols)=sigmas
    tmpc=noisy_env_omega[ noisy_env_omega$mu == 0.01 & noisy_env_omega$omega == o & noisy_env_omega$m == 0.2 ,]
    xrange=range(noisy_env_omega$delta)
    plot(tmpc$delta,tmpc$extinction,log="y",type="n",ylab="extinction time",xlab=expression(delta),main=bquote(mu == 0.01 ~ omega == .(o)),xlim=xrange)
    for(s in sigmas){
        tmpc=noisy_env_omega[ noisy_env_omega$sigma==s & noisy_env_omega$mu == 0.01 & noisy_env_omega$m == 0.2 & noisy_env_omega$omega == o,]
        for(k in 1:length(Ks)){
            t=tmpc[tmpc$K==Ks[k],]
            r=tapply(t$extinction,t$delta,mean)
            lines(sort(unique(t$delta)),r,type="b",pch=k,col=cols[as.character(s)])
        }
    }
    legend("bottomleft",
           legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
           col=c(rep(1,length(Ks)),cols),
           lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
           pch=c(seq_along(Ks),rep(NA,length(sigmas)))
           )
}
```

### Trajectories 

We can thus reproduce he trajectories and variance equilibrium using simulation with $\omega=1$ et $\omega=2$


Check the trajectory off the effective population when $\omega = 2$
```{r,fig.width=10,fig.height=10}
#pdf("trajectory_N_omega2.pdf",width=12,height=16)
plotAllTrajVar(omega2,m=0.05,E=0,obs="N")
#dev.off()
```

Check the trajectory off the mean variance:
```{r,fig.width=10,fig.height=10}
#pdf("trajectory_var_x_omega2.pdf",width=12,height=16)
plotAllTrajVar(omega2,m=0.05,E=0,obs="var_x",ylim=c(0,.02))
#dev.off()
```

### Variance at equilibrium

And check the variance at the end of the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_x_omega2.pdf",width=12,height=16)
plotAllVariableSummaries(omega2,E=0,estimate=eq2833b) #we use only simulations without noise
#dev.off()
```


## Moving optimum $\theta_t=vt$

###  Environment

```{r,fig.width=10,fig.height=10}
par(mfrow=c(3,3))
deltas=c(0,0.1,1)
vts=c(0.001,0.002,0.003)
cols=colorRampPalette(c("darkgreen","green"))(length(vts))
names(cols)=vts
omegas=1:2

for(d  in deltas){
    for(o  in omegas){
        plot(1,1,xlim=c(1,500),ylim=c(-(d+d*.1),1.1*500*max(vts)+d),type="n",xlab="t",ylab=expression(theta[t]),main=bquote(delta == .(d)~omega == .(o)))
        for ( vt in vts)
            lines(1:500,environment(500,omega=o,delta=d,vt=vt),col=cols[as.character(vt)])
        legend("topleft",legend=paste0("v=",vts),col=cols,lty=1)
    }
}
```


```{r, eval=FALSE}
moving_theta=getAlllSummaries("movingThetaXSmallVTBiggerMx")
moving_theta=updateScale(moving_theta)
save(file="data/moving_thetaGeneAlone.bin",moving_theta)
```

```{r}
load(file="data/moving_thetaGeneAlone.bin")
```

### Extinctions


```{r,fig.width=10,fig.cap="Extinction Time for different rates of environmental change"}
#pdf("extinctionsMovingTheta.pdf",width=17,height=4)
par(mfrow=c(1,3))
rates=sort(unique(moving_theta$vt))
sigmas=sort(unique(moving_theta$sigma))
deltas=sort(unique(moving_theta$delta))
Ks=sort(unique(moving_theta$K))
cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
names(cols)=sigmas
for(d in deltas){
    tmpcs=moving_theta[  moving_theta$mu == 0.001 & moving_theta$delta == d & moving_theta$m == 0.1 ,]
    #xrange=range(moving_theta$delta)
    plot(tmpcs$vt,tmpcs$extinction,log="y",type="n",ylab="extinction time",xlab=expression(v),main=bquote(delta == .(d)~mu == 0.01 ~  omega == .(o)))
    for(s in sigmas){
        tmpc=tmpcs[ tmpcs$sigma==s ,]
        for(k in 1:length(Ks)){
            t=tmpc[tmpc$K==Ks[k],]
            r=tapply(t$extinction,t$vt,mean)
            lines(sort(unique(t$vt)),r,type="b",pch=k,col=cols[as.character(s)])
        }
    }
    legend("bottomleft",
           legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
           col=c(rep(1,length(Ks)),cols),
           lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
           pch=c(seq_along(Ks),rep(NA,length(sigmas)))
           )
}
#dev.off()
```


### Trajectories 
For the trajectories lot of extreme rates doesn't produce  output (_ie_ extinct after a few generations), we don't take them into account:

```{r}
rates=rates[1:3]
```


Check the trajectory of  the effective population size:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    #pdf(paste0("trajectory_N_moving",t,".pdf"),width=12,height=16)
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="N")
    #dev.off()
}
```

Check the trajectory of the mean variance:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    #pdf(paste0("trajectory_var_x_moving",t,".pdf"),width=12,height=16)
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="var_x")
    #dev.off()
}
```

Check the trajectory of the distance to optimum:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    #pdf(paste0("trajectory_dist_moving",t,".pdf"),width=12,height=16)
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="dist")#,ylim=c(0,.005))
    #dev.off()
}
```

### Variance at equilibrium

Check and compare the final variance :

```{r,fig.fullwidth=T,fig.height=11,fig.cap="Variance at equilibrium"}
for(t in seq_along(rates)){
    #pdf(paste0("equilibrium_var_x_moving",t,".pdf"),width=12,height=16)
    print(paste("rate=",rates[t]))
    plotAllVariableSummaries(moving_theta[moving_theta$vt == rates[t],],E=0,estimate=eq2833b) 
    #dev.off()
}
```

<!--chapter:end:04_geneticOnly.Rmd-->


# Explore individual Learning evolution only: 

```{r echo=FALSE, message=FALSE}
knitr::opts_chunk$set(warning=FALSE,message=FALSE,out.width='100%',echo=TRUE)
source("tools.R")
source("protomodels.R")
source("toolsSummariesAndTraj.R")

do_it=FALSE

#save(file="data/constant_env.bin",constant_env)
#save(file="data/v.bin",v)
#save(file="data/noisy_env.bin",noisy_env)
#save(file="data/noisy_env_omega",noisy_env_omega)
#save(file="data/moving_theta",moving_theta)
#save(file="data/omega1.bin",omega1)
#save(file="data/omega2.bin",omega2)
#save(file="data/allStaticsY.bin",allStatics)

#load(file="data/constant_env.bin")
#load(file="data/v.bin")
#load(file="data/noisy_env.bin")
#load(file="data/noisy_env_omega")
#load(file="data/omega1.bin")
#load(file="data/omega2.bin")
#load(file="data/moving_theta")
load(file="data/allStaticsY.bin")

```


## Constant Environment

Fixed parameter:
```{r}
n=1000
b=2
tstep=50000
mu=c(x=0,y=0,z=0)
E=c(x=0,y=0,z=0)
m=c(x=0,y=0,z=0)
sigma=c(s=1,y=1,z=1)
```
Explored parameters:
```{r}
allparameters=list()
allparameters[["mu"]]=c(0.001,0.01)
allparameters[["K"]]=c(500,1000,2000)
allparameters[["E"]]=0 #no noise
allparameters[["m"]]=c(.05,.1,.2)
allparameters[["sigma"]]=c(1,2,4,10000)
allparameters[["delta"]]=c(0,.1,.2,.4,1)
allparameters[["vt"]]=0 #no rate of change
allparameters[["omega"]]=c(0,2)
allparameters[["outputrate"]]=100
parameters=as.data.frame(expand.grid(allparameters))
```

```{r,echo=F}
rmarkdown::paged_table(parameters)
```




```{r,eval=do_it}
allStatics=getAlllSummaries("allWithNotMovingThetaY/")
allStatics=updateScale(allStatics)
```

```{r}
constant_env=allStatics[allStatics$delta == 0,] 
```



### Trajectories

Check the trajectories of the simulation for the population size for different mutation rate $\mu$(from left to right: $\mu = 0, \mu = 0.001,\mu=0.01$), different selective pressure $\sigma_s$ (from top to bottomright: $\sigma_s = 0.1, \sigma_smu = 0.2,\sigma_s=0.4,\sigma_s=1000$) and  different carrying capacity $K$ 


```{r,fig.fullwidth=T,fig.height=10,fig.cap="Effective population size"}
#pdf("trajectory_N_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="N")
#dev.off()
```
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Variance"}
#pdf("trajectory_var_y_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="var_y",ylim=c(0,.02))
#dev.off()
```

```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Y"}
#pdf("trajectory_var_y_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_y")
#dev.off()
```

### Variance and Mean of Y at equilibrium

Check the variance at the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_y_const.pdf",width=12,height=16)
plotAllVariableSummaries(constant_env,E=0,estimate=NULL,var="var_y") #we use only simulations without noise
#dev.off()
```

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_y_const.pdf",width=12,height=16)
#plotAllVariableSummaries(constant_env,E=0,estimate=eq2833b,var="mean_y") #we use only simulations without noise
#dev.off()
```


## Constant but noisy environment
we use different  $\delta$  to generate environment with noise of growing variance

### Environment

```{r,fig.width=10,fig.height=5,fig.cap="effect of $\\delta$ on environment"}
d=c(0.00,0.01,0.10,0.20,0.40,1.00,10.00)
cols=colorRampPalette(c("black","grey"))(length(d))
names(cols)=d
omegas=1:2

plot(1,1,xlim=c(1,500),ylim=c(-10,10),type="n",xlab="t",ylab=expression(theta[t]))
for ( i in rev(d))
    lines(1:500,environment(500,omega=0,delta=i),col=cols[as.character(i)])
legend("topleft",legend=paste0("d=",d),col=cols,lty=1,bg="white")
```

To explore this we used the following parameters space:


```{r}
noisy_env = allStatics[allStatics$omega ==0,]
```


### Trajectories 

Check the trajectory of  the effective population size:
```{r,fig.width=20,fig.height=20}
#pdf("trajectory_N_noise.pdf",width=12,height=16)
plotAllTrajVar(noisy_env,m=0.05,E=0,obs="N")
#dev.off()
```

Check the trajectory of the mean variance:
```{r,fig.width=15,fig.height=10,fig.cap="Trajectory of Variance for noisy environment"}
#pdf("trajectory_var_y_noise.pdf",width=12,height=16)
plotAllTrajVar(noisy_env,m=0.05,E=0,obs="var_y",ylim=c(0,.03))
#dev.off()
```

Check the trajectory of the mean of Y:
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Y"}
#pdf("trajectory_var_y_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_y")
#dev.off()
```

### Variance and mean of Y at equilibrium

Check and compare the final variance :

```{r,fig.fullwidth=T,fig.height=10}
#pdf("equilibrium_var_y_noise.pdf",width=12,height=16)
plotAllVariableSummaries(noisy_env,E=0,estimate=eq2833b,var="var_y") 
#dev.off()
```
 
Check and compare the final mean :

```{r,fig.fullwidth=T,fig.height=10}
#pdf("equilibrium_var_y_noise.pdf",width=12,height=16)
#plotAllVariableSummaries(noisy_env,E=0,estimate=eq2833b,var="mean_y") 
#dev.off()
```



### Extinctions
Some of the data seems to be missing because when $\delta>\sigma$  we have extinctions, has shown in the Figure \@ref(fig:extinctionNoisy). 


```{r extinctionNoisyY,warning=FALSE}
#pdf
sigmas=unique(noisy_env$sigma)
cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
names(cols)=sigmas
tmpc=noisy_env[ noisy_env$mu == 0.01 & noisy_env$m == 0.2 ,]
plot(tmpc$delta,tmpc$extinction,log="xy",type="n",ylab="extinction time",xlab=expression(delta),main=bquote(mu == 0.01 ~ omega == 0))
for(s in sigmas){
    tmpc=noisy_env[ noisy_env$sigma==s & noisy_env$mu == 0.01 & noisy_env$m == 0.2 ,]
    Ks=sort(unique(tmpc$K))
    for(k in 1:length(Ks)){
        t=tmpc[tmpc$K==Ks[k],]
        r=tapply(t$extinction,t$delta,mean)
        lines(sort(unique(t$delta)),r,type="b",pch=k,col=cols[as.character(s)])
    }
}
legend("right",
       legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
       col=c(rep(1,length(Ks)),cols),
       lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
       pch=c(seq_along(Ks),rep(NA,length(sigmas)))
       )
#dev.off()
```


## Constant, noisy, with autocorrelation

To avoid some of the exctinctions we introduction autocorrelation in the environment


### Environment
To introduce autocorrelation we increase slightly $omega$ which gives environment like the one below.


```{r}
par(mfrow=c(1,3))
plot(1:500,environment(500,omega=1,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==1))
plot(1:500,environment(500,omega=2,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==2))
plot(1:500,environment(500,omega=3,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==4))
```


For this we re-run previous experiment but with $\omega \in {1,2}$

```{r}
noisy_env_omega = allStatics
omega2 = allStatics[ allStatics$omega==2,]
```


### Extinctions

Let's look at the extinctions again now that we have the different omegas


```{r,fig.width=10,out.width='100%',fig.cap="Extinction wrt to deltas for different omegas"}
par(mfrow=c(1,2))
omegas=unique(noisy_env_omega$omega)
sigmas=sort(unique(noisy_env_omega$sigma))
deltas=sort(unique(noisy_env_omega$delta))
Ks=sort(unique(noisy_env_omega$K))
for(o in omegas){
    cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
    names(cols)=sigmas
    tmpc=noisy_env_omega[ noisy_env_omega$mu == 0.01 & noisy_env_omega$omega == o & noisy_env_omega$m == 0.2 ,]
    xrange=range(noisy_env_omega$delta)
    plot(tmpc$delta,tmpc$extinction,log="y",type="n",ylab="extinction time",xlab=expression(delta),main=bquote(mu == 0.01 ~ omega == .(o)),xlim=xrange)
    for(s in sigmas){
        tmpc=noisy_env_omega[ noisy_env_omega$sigma==s & noisy_env_omega$mu == 0.01 & noisy_env_omega$m == 0.2 & noisy_env_omega$omega == o,]
        for(k in 1:length(Ks)){
            t=tmpc[tmpc$K==Ks[k],]
            r=tapply(t$extinction,t$delta,mean)
            lines(sort(unique(t$delta)),r,type="b",pch=k,col=cols[as.character(s)])
        }
    }
    legend("bottomleft",
           legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
           col=c(rep(1,length(Ks)),cols),
           lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
           pch=c(seq_along(Ks),rep(NA,length(sigmas)))
           )
}
```

### Trajectories 

We can thus reproduce he trajectories and variance equilibrium using simulation with $\omega=1$ et $\omega=2$


Check the trajectory of the effective population when $\omega = 2$
```{r,fig.width=10,fig.height=10}
#pdf("trajectory_N_omega2.pdf",width=12,height=16)
plotAllTrajVar(omega2,m=0.05,E=0,obs="N")
#dev.off()
```

Check the trajectory of the mean variance:
```{r,fig.width=10,fig.height=10}
#pdf("trajectory_var_y_omega2.pdf",width=12,height=16)
plotAllTrajVar(omega2,m=0.05,E=0,obs="var_y",ylim=c(0,.02))
#dev.off()
```

Check the trajectory of the mean of Y:
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Y"}
#pdf("trajectory_var_y_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_y")
#dev.off()
```
### Variance at equilibrium

And check the variance at the end of the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_y_omega2.pdf",width=12,height=16)
plotAllVariableSummaries(omega2,E=0,estimate=eq2833b,var="var_y") #we use only simulations without noise
#dev.off()
```

And check the mean at the end of the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_y_omega2.pdf",width=12,height=16)
#plotAllVariableSummaries(omega2,E=0,estimate=eq2833b,var="mean_y") #we use only simulations without noise
#dev.off()
```

## Moving optimum $\theta_t=vt$

```{r, eval=FALSE}
moving_theta=getAlllSummaries("allIndividualMovingTheta/")
moving_theta=updateScale(moving_theta)
save(file="data/moving_thetaIndivAlone.bin",moving_theta)
```
```{r}
load(file="data/moving_thetaIndivAlone.bin")
```

### Extinctions


```{r,fig.width=10,fig.cap="Extinction Time for different rates of environmental change"}
#pdf("extinctionsMovingTheta.pdf",width=17,height=4)
par(mfrow=c(1,3))
rates=sort(unique(moving_theta$vt))
sigmas=sort(unique(moving_theta$sigma))
deltas=sort(unique(moving_theta$delta))
Ks=sort(unique(moving_theta$K))
cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
names(cols)=sigmas
for(d in deltas){
    tmpcs=moving_theta[  moving_theta$mu == 0.001 & moving_theta$delta == d & moving_theta$m == 0.1 ,]
    #xrange=range(moving_theta$delta)
    plot(tmpcs$vt,tmpcs$extinction,log="y",type="n",ylab="extinction time",xlab=expression(v),main=bquote(delta == .(d)~mu == 0.01 ~  omega == .(o)))
    for(s in sigmas){
        tmpc=tmpcs[ tmpcs$sigma==s ,]
        for(k in 1:length(Ks)){
            t=tmpc[tmpc$K==Ks[k],]
            r=tapply(t$extinction,t$vt,mean)
            lines(sort(unique(t$vt)),r,type="b",pch=k,col=cols[as.character(s)])
        }
    }
    legend("bottomleft",
           legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
           col=c(rep(1,length(Ks)),cols),
           lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
           pch=c(seq_along(Ks),rep(NA,length(sigmas)))
           )
}
#dev.off()
```


### Trajectories 
For the trajectories lot of extreme rates doesn't produce  output (_ie_ extinct after a few generations), we don't take them into account:

```{r}
rates=rates[1:3]
```


Check the trajectory of  the effective population size:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    #pdf(paste0("trajectory_N_moving",t,".pdf"),width=12,height=16)
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="N")
    #dev.off()
}
```

Check the trajectory of the mean variance:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="var_y")
    #dev.off()
}
```

Check the trajectory of the distance to optimum:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    #pdf(paste0("trajectory_dist_moving",t,".pdf"),width=12,height=16)
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="dist")#,ylim=c(0,.005))
    #dev.off()
}
```

### Equilibrium

####  Variance of Z

```{r,fig.fullwidth=T,fig.height=11,fig.cap="Variance at equilibrium"}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllVariableSummaries(moving_theta[moving_theta$vt == rates[t],],E=0,estimate=NULL,var="var_y") 
    #dev.off()
}
```

####  Mean fitness
```{r,fig.fullwidth=T,fig.height=11,fig.cap="Variance at equilibrium"}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllVariableSummaries(moving_theta[moving_theta$vt == rates[t],],E=0,estimate=NULL,var="mean_w") 
    #dev.off()
}
```


<!--chapter:end:05_individualLearningOnly.Rmd-->


# Explore Social Learning (Copy Best) evolution only: 

```{r echo=FALSE, message=FALSE}
knitr::opts_chunk$set(warning=FALSE,message=FALSE,out.width='100%',echo=TRUE)
source("tools.R")
source("protomodels.R")
source("toolsSummariesAndTraj.R")

do_it=FALSE

#save(file="data/constant_env.bin",constant_env)
#save(file="data/v.bin",v)
#save(file="data/noisy_env.bin",noisy_env)
#save(file="data/noisy_env_omega",noisy_env_omega)
#save(file="data/moving_theta",moving_theta)
#save(file="data/omega1.bin",omega1)
#save(file="data/omega2.bin",omega2)
#save(file="data/allStaticsY.bin",allStatics)

#load(file="data/constant_env.bin")
#load(file="data/v.bin")
#load(file="data/noisy_env.bin")
#load(file="data/noisy_env_omega")
#load(file="data/omega1.bin")
#load(file="data/omega2.bin")
#load(file="data/moving_theta")
#load(file="data/allStaticsY.bin")
load(file="data/allWithNotMovingThetaZCorrected.bin")

```


## Constant Environment

Fixed parameter:
```{r}
n=1000
b=2
tstep=50000
mu=c(x=0,y=0,z=0)
E=c(x=0,y=0,z=0)
m=c(x=0,y=0,z=0)
sigma=c(s=1,y=1,z=1)
```
Explored parameters:
```{r}
allparameters=list()
allparameters[["mu"]]=c(0.001,0.01)
allparameters[["K"]]=c(500,1000,2000)
allparameters[["E"]]=0 #no noise
allparameters[["m"]]=c(.05,.1,.2)
allparameters[["sigma"]]=c(1,2,4,10000)
allparameters[["delta"]]=c(0,.1,.2,.4,1)
allparameters[["vt"]]=0 #no rate of change
allparameters[["omega"]]=c(0,2)
allparameters[["outputrate"]]=100
parameters=as.data.frame(expand.grid(allparameters))
```

```{r,echo=F}
rmarkdown::paged_table(parameters)
```




```{r,eval=do_it}
allStatics=getAlllSummaries("allWithNotMovingThetaZCorrected")
allStatics=updateScale(allStatics)
```

```{r}
constant_env=allStatics[allStatics$delta == 0,] 
```



### Trajectories

Check the trajectories of the simulation for the population size for different mutation rate $\mu$(from left to right: $\mu = 0, \mu = 0.001,\mu=0.01$), different selective pressure $\sigma_s$ (from top to bottomright: $\sigma_s = 0.1, \sigma_smu = 0.2,\sigma_s=0.4,\sigma_s=1000$) and  different carrying capacity $K$ 


```{r,fig.fullwidth=T,fig.height=10,fig.cap="Effective population size"}
#pdf("trajectory_N_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="N")
#dev.off()
```
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Variance"}
#pdf("trajectory_var_z_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="var_z",ylim=c(0,.02))
#dev.off()
```

```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Y"}
#pdf("trajectory_var_z_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_z")
#dev.off()
```

### Variance and Mean of Y at equilibrium

Check the variance at the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_const.pdf",width=12,height=16)
plotAllVariableSummaries(constant_env,E=0,estimate=eq2833b,var="var_z") #we use only simulations without noise
#dev.off()
```

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_const.pdf",width=12,height=16)
#plotAllVariableSummaries(constant_env,E=0,estimate=eq2833b,var="mean_y") #we use only simulations without noise
#dev.off()
```


## Constant but noisy environment
we use different  $\delta$  to generate environment with noise of growing variance

### Environment

```{r,fig.width=10,fig.height=5,fig.cap="effect of $\\delta$ on environment"}
d=c(0.00,0.01,0.10,0.20,0.40,1.00,10.00)
cols=colorRampPalette(c("black","grey"))(length(d))
names(cols)=d
omegas=1:2

plot(1,1,xlim=c(1,500),ylim=c(-10,10),type="n",xlab="t",ylab=expression(theta[t]))
for ( i in rev(d))
    lines(1:500,environment(500,omega=0,delta=i),col=cols[as.character(i)])
legend("topleft",legend=paste0("d=",d),col=cols,lty=1,bg="white")
```

To explore this we used the following parameters space:


```{r}
noisy_env = allStatics[allStatics$omega ==0,]
```


### Trajectories 

Check the trajectory of  the effective population size:
```{r,fig.width=20,fig.height=20}
#pdf("trajectory_N_noise.pdf",width=12,height=16)
plotAllTrajVar(noisy_env,m=0.05,E=0,obs="N")
#dev.off()
```

Check the trajectory of the mean variance:
```{r,fig.width=15,fig.height=10,fig.cap="Trajectory of Variance for noisy environment"}
#pdf("trajectory_var_z_noise.pdf",width=12,height=16)
plotAllTrajVar(noisy_env,m=0.05,E=0,obs="var_z",ylim=c(0,.03))
#dev.off()
```

Check the trajectory of the mean of Y:
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Y"}
#pdf("trajectory_var_z_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_z")
#dev.off()
```

### Variance and mean of Y at equilibrium

Check and compare the final variance :

```{r,fig.fullwidth=T,fig.height=10}
#pdf("equilibrium_var_z_noise.pdf",width=12,height=16)
plotAllVariableSummaries(noisy_env,E=0,estimate=eq2833b,var="var_z") 
#dev.off()
```
 
Check and compare the final mean :

```{r,fig.fullwidth=T,fig.height=10}
#pdf("equilibrium_var_z_noise.pdf",width=12,height=16)
#plotAllVariableSummaries(noisy_env,E=0,estimate=eq2833b,var="mean_y") 
#dev.off()
```



### Extinctions
Some of the data seems to be missing because when $\delta>\sigma$  we have extinctions, has shown in the Figure #\@ref(fig:extinctionNoisy). 


```{r,warning=FALSE}
#pdf
sigmas=unique(noisy_env$sigma)
cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
names(cols)=sigmas
tmpc=noisy_env[ noisy_env$mu == 0.01 & noisy_env$m == 0.2 ,]
plot(tmpc$delta,tmpc$extinction,log="xy",type="n",ylab="extinction time",xlab=expression(delta),main=bquote(mu == 0.01 ~ omega == 0))
for(s in sigmas){
    tmpc=noisy_env[ noisy_env$sigma==s & noisy_env$mu == 0.01 & noisy_env$m == 0.2 ,]
    Ks=sort(unique(tmpc$K))
    for(k in 1:length(Ks)){
        t=tmpc[tmpc$K==Ks[k],]
        r=tapply(t$extinction,t$delta,mean)
        lines(sort(unique(t$delta)),r,type="b",pch=k,col=cols[as.character(s)])
    }
}
legend("right",
       legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
       col=c(rep(1,length(Ks)),cols),
       lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
       pch=c(seq_along(Ks),rep(NA,length(sigmas)))
       )
#dev.off()
```


## Constant, noisy, with autocorrelation

To avoid some of the exctinctions we introduction autocorrelation in the environment


### Environment
To introduce autocorrelation we increase slightly $omega$ which gives environment like the one below.


```{r}
par(mfrow=c(1,3))
plot(1:500,environment(500,omega=1,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==1))
plot(1:500,environment(500,omega=2,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==2))
plot(1:500,environment(500,omega=3,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==4))
```


For this we re-run previous experiment but with $\omega \in {1,2}$

```{r}
noisy_env_omega = allStatics
omega2 = allStatics[ allStatics$omega==2,]
```


### Extinctions

Let's look at the extinctions again now that we have the different omegas


```{r,fig.width=10,out.width='100%',fig.cap="Extinction wrt to deltas for different omegas"}
par(mfrow=c(1,2))
omegas=unique(noisy_env_omega$omega)
sigmas=sort(unique(noisy_env_omega$sigma))
deltas=sort(unique(noisy_env_omega$delta))
Ks=sort(unique(noisy_env_omega$K))
for(o in omegas){
    cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
    names(cols)=sigmas
    tmpc=noisy_env_omega[ noisy_env_omega$mu == 0.01 & noisy_env_omega$omega == o & noisy_env_omega$m == 0.2 ,]
    xrange=range(noisy_env_omega$delta)
    plot(tmpc$delta,tmpc$extinction,log="y",type="n",ylab="extinction time",xlab=expression(delta),main=bquote(mu == 0.01 ~ omega == .(o)),xlim=xrange)
    for(s in sigmas){
        tmpc=noisy_env_omega[ noisy_env_omega$sigma==s & noisy_env_omega$mu == 0.01 & noisy_env_omega$m == 0.2 & noisy_env_omega$omega == o,]
        for(k in 1:length(Ks)){
            t=tmpc[tmpc$K==Ks[k],]
            r=tapply(t$extinction,t$delta,mean)
            lines(sort(unique(t$delta)),r,type="b",pch=k,col=cols[as.character(s)])
        }
    }
    legend("bottomleft",
           legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
           col=c(rep(1,length(Ks)),cols),
           lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
           pch=c(seq_along(Ks),rep(NA,length(sigmas)))
           )
}
```

### Trajectories 

We can thus reproduce he trajectories and variance equilibrium using simulation with $\omega=1$ et $\omega=2$


Check the trajectory of the effective population when $\omega = 2$
```{r,fig.width=10,fig.height=10}
#pdf("trajectory_N_omega2.pdf",width=12,height=16)
plotAllTrajVar(omega2,m=0.05,E=0,obs="N")
#dev.off()
```

Check the trajectory of the mean variance:
```{r,fig.width=10,fig.height=10}
#pdf("trajectory_var_z_omega2.pdf",width=12,height=16)
plotAllTrajVar(omega2,m=0.05,E=0,obs="var_z",ylim=c(0,.02))
#dev.off()
```

Check the trajectory of the mean of Y:
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Y"}
#pdf("trajectory_var_z_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_z")
#dev.off()
```
### Variance at equilibrium

And check the variance at the end of the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_omega2.pdf",width=12,height=16)
plotAllVariableSummaries(omega2,E=0,estimate=eq2833b,var="var_z") #we use only simulations without noise
#dev.off()
```

And check the mean at the end of the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_omega2.pdf",width=12,height=16)
#plotAllVariableSummaries(omega2,E=0,estimate=eq2833b,var="mean_y") #we use only simulations without noise
#dev.off()
```

<!--chapter:end:06_socialLeanringOnlyBest.Rmd-->


# Explore Social Learning (Random Copy) evolution only: 

```{r echo=FALSE, message=FALSE}
knitr::opts_chunk$set(warning=FALSE,message=FALSE,out.width='100%',echo=TRUE)
source("tools.R")
source("protomodels.R")
source("toolsSummariesAndTraj.R")

do_it=FALSE

#save(file="data/constant_env.bin",constant_env)
#save(file="data/v.bin",v)
#save(file="data/noisy_env.bin",noisy_env)
#save(file="data/noisy_env_omega",noisy_env_omega)
#save(file="data/moving_theta",moving_theta)
#save(file="data/omega1.bin",omega1)
#save(file="data/omega2.bin",omega2)
#save(file="data/allStaticsY.bin",allStatics)

#load(file="data/constant_env.bin")
#load(file="data/v.bin")
#load(file="data/noisy_env.bin")
#load(file="data/noisy_env_omega")
#load(file="data/omega1.bin")
#load(file="data/omega2.bin")
#load(file="data/moving_theta")
#load(file="data/allStaticsY.bin")
load(file="data/allWithNotMovingThetaZCorrectedRandom.bin")

```


## Constant Environment

Fixed parameter:
```{r}
n=1000
b=2
tstep=50000
mu=c(x=0,y=0,z=0)
E=c(x=0,y=0,z=0)
m=c(x=0,y=0,z=0)
sigma=c(s=1,y=1,z=1)
```
Explored parameters:
```{r}
allparameters=list()
allparameters[["mu"]]=c(0.001,0.01)
allparameters[["K"]]=c(500,1000,2000)
allparameters[["E"]]=0 #no noise
allparameters[["m"]]=c(.05,.1,.2)
allparameters[["sigma"]]=c(1,2,4,10000)
allparameters[["delta"]]=c(0,.1,.2,.4,1)
allparameters[["vt"]]=0 #no rate of change
allparameters[["omega"]]=c(0,2)
allparameters[["outputrate"]]=100
parameters=as.data.frame(expand.grid(allparameters))
```

```{r,echo=F}
rmarkdown::paged_table(parameters)
```




```{r,eval=do_it}
allStatics=getAlllSummaries("allWithNotMovingThetaZCorrectedRandom")
allStatics=updateScale(allStatics)
```

```{r}
constant_env=allStatics[allStatics$delta == 0,] 
```



### Trajectories

Check the trajectories of the simulation for the population size for different mutation rate $\mu$(from left to right: $\mu = 0, \mu = 0.001,\mu=0.01$), different selective pressure $\sigma_s$ (from top to bottomright: $\sigma_s = 0.1, \sigma_smu = 0.2,\sigma_s=0.4,\sigma_s=1000$) and  different carrying capacity $K$ 

#### Effective pop Size

```{r,fig.fullwidth=T,fig.height=10,fig.cap="Effective population size"}
#pdf("trajectory_N_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="N")
#dev.off()
```

#### Variance of z

```{r,fig.fullwidth=T,fig.height=10,fig.cap="Variance"}
#pdf("trajectory_var_z_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="var_z",ylim=c(0,.02))
#dev.off()
```

#### Mean of z

```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Z"}
#pdf("trajectory_var_z_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_z")
#dev.off()
```

### Variance of Z at equilibrium

Check the variance at the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_const.pdf",width=12,height=16)
plotAllVariableSummaries(constant_env,E=0,estimate=eq2833b,var="var_z") #we use only simulations without noise
#dev.off()
```

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_const.pdf",width=12,height=16)
#plotAllVariableSummaries(constant_env,E=0,estimate=eq2833b,var="mean_y") #we use only simulations without noise
#dev.off()
```

### Mean Fitness

Check the variance at the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_const.pdf",width=12,height=16)
plotAllVariableSummaries(constant_env,E=0,estimate=eq2833b,var="mean_w") #we use only simulations without noise
#dev.off()
```

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_const.pdf",width=12,height=16)
#plotAllVariableSummaries(constant_env,E=0,estimate=eq2833b,var="mean_y") #we use only simulations without noise
#dev.off()
```

## Constant but noisy environment
we use different  $\delta$  to generate environment with noise of growing variance

### Environment

```{r,fig.width=10,fig.height=5,fig.cap="effect of $\\delta$ on environment"}
d=c(0.00,0.01,0.10,0.20,0.40,1.00,10.00)
cols=colorRampPalette(c("black","grey"))(length(d))
names(cols)=d
omegas=1:2

plot(1,1,xlim=c(1,500),ylim=c(-10,10),type="n",xlab="t",ylab=expression(theta[t]))
for ( i in rev(d))
    lines(1:500,environment(500,omega=0,delta=i),col=cols[as.character(i)])
legend("topleft",legend=paste0("d=",d),col=cols,lty=1,bg="white")
```

To explore this we used the following parameters space:


```{r}
noisy_env = allStatics[allStatics$omega ==0,]
```


### Trajectories 

Check the trajectory of  the effective population size:
```{r,fig.width=20,fig.height=20}
#pdf("trajectory_N_noise.pdf",width=12,height=16)
plotAllTrajVar(noisy_env,m=0.05,E=0,obs="N")
#dev.off()
```

Check the trajectory of the mean variance:
```{r,fig.width=15,fig.height=10,fig.cap="Trajectory of Variance for noisy environment"}
#pdf("trajectory_var_z_noise.pdf",width=12,height=16)
plotAllTrajVar(noisy_env,m=0.05,E=0,obs="var_z",ylim=c(0,.03))
#dev.off()
```

Check the trajectory of the mean of Z:
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Y"}
#pdf("trajectory_var_z_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_z")
#dev.off()
```

### Variance and mean of Y at equilibrium

Check and compare the final variance :

```{r,fig.fullwidth=T,fig.height=10}
#pdf("equilibrium_var_z_noise.pdf",width=12,height=16)
plotAllVariableSummaries(noisy_env,E=0,estimate=eq2833b,var="var_z") 
#dev.off()
```
 
Check and compare the final mean :

```{r,fig.fullwidth=T,fig.height=10}
#pdf("equilibrium_var_z_noise.pdf",width=12,height=16)
#plotAllVariableSummaries(noisy_env,E=0,estimate=eq2833b,var="mean_y") 
#dev.off()
```



### Extinctions
Some of the data seems to be missing because when $\delta>\sigma$  we have extinctions, has shown in the Figure #\@ref(fig:extinctionNoisy). 


```{r,warning=FALSE}
#pdf
sigmas=unique(noisy_env$sigma)
cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
names(cols)=sigmas
tmpc=noisy_env[ noisy_env$mu == 0.01 & noisy_env$m == 0.2 ,]
plot(tmpc$delta,tmpc$extinction,log="xy",type="n",ylab="extinction time",xlab=expression(delta),main=bquote(mu == 0.01 ~ omega == 0))
for(s in sigmas){
    tmpc=noisy_env[ noisy_env$sigma==s & noisy_env$mu == 0.01 & noisy_env$m == 0.2 ,]
    Ks=sort(unique(tmpc$K))
    for(k in 1:length(Ks)){
        t=tmpc[tmpc$K==Ks[k],]
        r=tapply(t$extinction,t$delta,mean)
        lines(sort(unique(t$delta)),r,type="b",pch=k,col=cols[as.character(s)])
    }
}
legend("right",
       legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
       col=c(rep(1,length(Ks)),cols),
       lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
       pch=c(seq_along(Ks),rep(NA,length(sigmas)))
       )
#dev.off()
```


## Constant, noisy, with autocorrelation

To avoid some of the exctinctions we introduction autocorrelation in the environment


### Environment
To introduce autocorrelation we increase slightly $omega$ which gives environment like the one below.


```{r}
par(mfrow=c(1,3))
plot(1:500,environment(500,omega=1,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==1))
plot(1:500,environment(500,omega=2,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==2))
plot(1:500,environment(500,omega=3,delta=.1),type="l",xlab="t",ylab=expression(theta[t]),main=expression(omega==4))
```


For this we re-run previous experiment but with $\omega \in {1,2}$

```{r}
noisy_env_omega = allStatics
omega2 = allStatics[ allStatics$omega==2,]
```


### Extinctions

Let's look at the extinctions again now that we have the different omegas


```{r,fig.width=10,out.width='100%',fig.cap="Extinction wrt to deltas for different omegas"}
par(mfrow=c(1,2))
omegas=unique(noisy_env_omega$omega)
sigmas=sort(unique(noisy_env_omega$sigma))
deltas=sort(unique(noisy_env_omega$delta))
Ks=sort(unique(noisy_env_omega$K))
for(o in omegas){
    cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
    names(cols)=sigmas
    tmpc=noisy_env_omega[ noisy_env_omega$mu == 0.01 & noisy_env_omega$omega == o & noisy_env_omega$m == 0.2 ,]
    xrange=range(noisy_env_omega$delta)
    plot(tmpc$delta,tmpc$extinction,log="y",type="n",ylab="extinction time",xlab=expression(delta),main=bquote(mu == 0.01 ~ omega == .(o)),xlim=xrange)
    for(s in sigmas){
        tmpc=noisy_env_omega[ noisy_env_omega$sigma==s & noisy_env_omega$mu == 0.01 & noisy_env_omega$m == 0.2 & noisy_env_omega$omega == o,]
        for(k in 1:length(Ks)){
            t=tmpc[tmpc$K==Ks[k],]
            r=tapply(t$extinction,t$delta,mean)
            lines(sort(unique(t$delta)),r,type="b",pch=k,col=cols[as.character(s)])
        }
    }
    legend("bottomleft",
           legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
           col=c(rep(1,length(Ks)),cols),
           lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
           pch=c(seq_along(Ks),rep(NA,length(sigmas)))
           )
}
```

### Trajectories 

We can thus reproduce he trajectories and variance equilibrium using simulation with $\omega=1$ et $\omega=2$


Check the trajectory of the effective population when $\omega = 2$
```{r,fig.width=10,fig.height=10}
#pdf("trajectory_N_omega2.pdf",width=12,height=16)
plotAllTrajVar(omega2,m=0.05,E=0,obs="N")
#dev.off()
```

Check the trajectory of the mean variance:
```{r,fig.width=10,fig.height=10}
#pdf("trajectory_var_z_omega2.pdf",width=12,height=16)
plotAllTrajVar(omega2,m=0.05,E=0,obs="var_z",ylim=c(0,.02))
#dev.off()
```

Check the trajectory of the mean of Y:
```{r,fig.fullwidth=T,fig.height=10,fig.cap="Mean Value of Y"}
#pdf("trajectory_var_z_const.pdf",width=12,height=16)
plotAllTrajVar(constant_env,m=0.05,E=0,obs="mean_z")
#dev.off()
```
### Variance at equilibrium

And check the variance at the end of the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_omega2.pdf",width=12,height=16)
plotAllVariableSummaries(omega2,E=0,estimate=eq2833b,var="var_z") #we use only simulations without noise
#dev.off()
```

And check the mean at the end of the equilibrium:

```{r,fig.fullwidth=T,fig.height=11,warnings=F,message=F}
#pdf("equilibrium_var_z_omega2.pdf",width=12,height=16)
#plotAllVariableSummaries(omega2,E=0,estimate=eq2833b,var="mean_y") #we use only simulations without noise
#dev.off()
```

## Moving optimum $\theta_t=vt$


```{r}
moving_theta=getAlllSummaries("allSocialMovingTheta/")
moving_theta=updateScale(moving_theta)
```

### Extinctions


```{r,fig.width=10,fig.cap="Extinction Time for different rates of environmental change"}
#pdf("extinctionsMovingTheta.pdf",width=17,height=4)
par(mfrow=c(1,3))
rates=sort(unique(moving_theta$vt))
sigmas=sort(unique(moving_theta$sigma))
deltas=sort(unique(moving_theta$delta))
Ks=sort(unique(moving_theta$K))
cols=colorRampPalette(c("darkgreen","yellow"))(length(sigmas))
names(cols)=sigmas
for(d in deltas){
    tmpcs=moving_theta[  moving_theta$mu == 0.001 & moving_theta$delta == d & moving_theta$m == 0.1 ,]
    #xrange=range(moving_theta$delta)
    plot(tmpcs$vt,tmpcs$extinction,log="y",type="n",ylab="extinction time",xlab=expression(v),main=bquote(delta == .(d)~mu == 0.01 ~  omega == .(o)))
    for(s in sigmas){
        tmpc=tmpcs[ tmpcs$sigma==s ,]
        for(k in 1:length(Ks)){
            t=tmpc[tmpc$K==Ks[k],]
            r=tapply(t$extinction,t$vt,mean)
            lines(sort(unique(t$vt)),r,type="b",pch=k,col=cols[as.character(s)])
        }
    }
    legend("bottomleft",
           legend=c(paste0("K=",Ks),sapply(sigmas,function(s)as.expression(bquote(sigma==.(s))))),
           col=c(rep(1,length(Ks)),cols),
           lty=c(rep(NA,length(Ks)),rep(1,length(sigmas))),
           pch=c(seq_along(Ks),rep(NA,length(sigmas)))
           )
}
#dev.off()
```


### Trajectories 
For the trajectories lot of extreme rates doesn't produce  output (_ie_ extinct after a few generations), we don't take them into account:

```{r}
rates=rates[1:3]
```


Check the trajectory of  the effective population size:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    #pdf(paste0("trajectory_N_moving",t,".pdf"),width=12,height=16)
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="N")
    #dev.off()
}
```

Check the trajectory of the mean variance:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    #pdf(paste0("trajectory_var_x_moving",t,".pdf"),width=12,height=16)
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="var_z")
    #dev.off()
}
```

Check the trajectory of the distance to optimum:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    #pdf(paste0("trajectory_dist_moving",t,".pdf"),width=12,height=16)
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="dist")#,ylim=c(0,.005))
    #dev.off()
}
```

### Equilibrium

Check and compare the final variance :

####  Variance of Z

```{r,fig.fullwidth=T,fig.height=11,fig.cap="Variance at equilibrium"}
for(t in seq_along(rates)){
    #pdf(paste0("equilibrium_var_x_moving",t,".pdf"),width=12,height=16)
    print(paste("rate=",rates[t]))
    plotAllVariableSummaries(moving_theta[moving_theta$vt == rates[t],],E=0,estimate=NULL,var="var_z") 
    #dev.off()
}
```

####  Mean fitness
```{r,fig.fullwidth=T,fig.height=11,fig.cap="Variance at equilibrium"}
for(t in seq_along(rates)){
    #pdf(paste0("equilibrium_var_x_moving",t,".pdf"),width=12,height=16)
    print(paste("rate=",rates[t]))
    plotAllVariableSummaries(moving_theta[moving_theta$vt == rates[t],],E=0,estimate=NULL,var="mean_w") 
    #dev.off()
}
```

<!--chapter:end:07_socialLeanringOnlyRandom.Rmd-->

# Full Genome, Best Social Learning

```{r,eval=FALSE}
moving_theta=getAlllSummaries("fullGenomesAllmeans")
moving_theta=updateScale(moving_theta)
```

## Moving Optimum


```{r}
load(file="data/fullgenome.bin")
rates=sort(unique(moving_theta$vt))
```


#### Population Size
Check the trajectory of  the effective population size:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="N")
}
```

### Distance to Optimum
Check the trajectory of the distance to optimum:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="dist")#,ylim=c(0,.005))
}
```

###  Fitness
Check the trajectory of the distance to optimum:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="mean_w")#,ylim=c(0,.005))
}
```

```{r,fig.width=10,fig.height=10}
plotAllVariableSummaries(moving_theta,E=0,estimate=NULL,var="mean_x") #we use only simulations without noise
plotAllVariableSummaries(moving_theta,E=0,estimate=NULL,var="mean_y") #we use only simulations without noise
plotAllVariableSummaries(moving_theta,E=0,estimate=NULL,var="mean_z") #we use only simulations without noise
```

<!--chapter:end:08_compareThreeOnly.Rmd-->

# Full Genome, Best Social Learning

```{r,eval=FALSE}
moving_theta=getAlllSummaries("fullGenomesAllmeans/")
moving_theta=updateScale(moving_theta)
```

## Moving Optimum


```{r}
load(file="data/fullgenome.bin")
rates=sort(unique(moving_theta$vt))
```


#### Population Size
Check the trajectory of  the effective population size:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="N")
}
```

### Distance to Optimum
Check the trajectory of the distance to optimum:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="dist")#,ylim=c(0,.005))
}
```

###  Fitness
Check the trajectory of the distance to optimum:
```{r,fig.width=10,fig.height=10}
for(t in seq_along(rates)){
    print(paste("rate=",rates[t]))
    plotAllTrajVar(moving_theta[moving_theta$vt == rates[t],],m=0.2,E=0,obs="mean_w")#,ylim=c(0,.005))
}
```

```{r,fig.width=10,fig.height=10}
plotAllVariableSummaries(moving_theta,E=0,estimate=NULL,var="mean_x") #we use only simulations without noise
plotAllVariableSummaries(moving_theta,E=0,estimate=NULL,var="mean_y") #we use only simulations without noise
plotAllVariableSummaries(moving_theta,E=0,estimate=NULL,var="mean_z") #we use only simulations without noise
```

<!--chapter:end:09_compareThreeOnly.Rmd-->

# Full Genome, Random Social Learning

So far all simulations with the full genome are done with a cost for y and z = 1

```{r,eval=TRUE}
load(file="data/fullgenomeRandom.bin")
moving_thetaRandom=moving_theta
moving_thetaRandom$distX=abs(moving_thetaRandom$theta - moving_thetaRandom$mean_x)
load(file="data/fullgenome.bin")
moving_thetaBest=moving_theta
moving_thetaBest$distX=abs(moving_thetaBest$theta - moving_thetaBest$mean_x)
```

```{r}
uniquesetupRandomMULT=moving_thetaRandom[ moving_thetaRandom$sigma == 1 & moving_thetaRandom$delta == 1 & moving_thetaRandom$m == .5 & moving_thetaRandom$vt == .001 & moving_thetaRandom$K == 2000 & moving_thetaRandom$mu == 0.01 & moving_thetaRandom$omega == 4,]
uniquesetupRandomMuLT=moving_thetaRandom[ moving_thetaRandom$sigma == 1 & moving_thetaRandom$delta == 1 & moving_thetaRandom$m == .5 & moving_thetaRandom$vt == .001 & moving_thetaRandom$K == 2000 & moving_thetaRandom$mu == 0.001 & moving_thetaRandom$omega == 4,]
uniquesetupBestMULT=moving_thetaBest[ moving_thetaBest$sigma == 1 & moving_thetaBest$delta == 1 & moving_thetaBest$m == .5 & moving_thetaBest$vt == .001 & moving_thetaBest$K == 2000 & moving_thetaBest$mu == 0.01 & moving_thetaBest$omega == 4,]
uniquesetupBestMuLT=moving_thetaBest[ moving_thetaBest$sigma == 1 & moving_thetaBest$delta == 1 & moving_thetaBest$m == .5 & moving_thetaBest$vt == .001 & moving_thetaBest$K == 2000 & moving_thetaBest$mu == 0.001 & moving_thetaBest$omega == 4,]

uniquesetupRandomMUHT=moving_thetaRandom[ moving_thetaRandom$sigma == 1 & moving_thetaRandom$delta == 1 & moving_thetaRandom$m == .5 & moving_thetaRandom$vt == .02 & moving_thetaRandom$K == 2000 & moving_thetaRandom$mu == 0.01 & moving_thetaRandom$omega == 4,]
uniquesetupRandomMuHT=moving_thetaRandom[ moving_thetaRandom$sigma == 1 & moving_thetaRandom$delta == 1 & moving_thetaRandom$m == .5 & moving_thetaRandom$vt == .02 & moving_thetaRandom$K == 2000 & moving_thetaRandom$mu == 0.001 & moving_thetaRandom$omega == 4,]
uniquesetupBestMUHT=moving_thetaBest[ moving_thetaBest$sigma == 1 & moving_thetaBest$delta == 1 & moving_thetaBest$m == .5 & moving_thetaBest$vt == .02 & moving_thetaBest$K == 2000 & moving_thetaBest$mu == 0.01 & moving_thetaBest$omega == 4,]
uniquesetupBestMuHT=moving_thetaBest[ moving_thetaBest$sigma == 1 & moving_thetaBest$delta == 1 & moving_thetaBest$m == .5 & moving_thetaBest$vt == .02 & moving_thetaBest$K == 2000 & moving_thetaBest$mu == 0.001 & moving_thetaBest$omega == 4,]
```


## Mean fitness with and distance to $\theta$

### Low rate of change  ($vt = 0.01$)
Random Social Learning (top), Best Social Learning (bottom)  high $\mu=0.01$ (left), low $\mu = 0.001$ (right)
```{r}
par(mfrow=c(2,2))
plotDistVsFitness(uniquesetupRandomMULT,main="mu=0.01, random copy")
plotDistVsFitness(uniquesetupRandomMuLT,main="mu=0.001, random copy")
plotDistVsFitness(uniquesetupBestMULT,main="mu=0.01, copy the best")
plotDistVsFitness(uniquesetupBestMuLT,main="mu=0.001, copy the best")
```

### High rate of change ($vt = 0.2$)
Random Social Learning (top), Best Social Learning (bottom)  high $\mu=0.01$ (left), low $\mu = 0.001$ (right)
```{r}
par(mfrow=c(2,2))
plotDistVsFitness(uniquesetupRandomMUHT,main="mu=0.01, random copy")
plotDistVsFitness(uniquesetupRandomMuHT,main="mu=0.001, random copy")
plotDistVsFitness(uniquesetupBestMUHT,main="mu=0.01, copy the best")
plotDistVsFitness(uniquesetupBestMuHT,main="mu=0.001,copy the best")
```

## Compare the mean value of the three genes during the simulation

### Low rate of change ($vt = 0.01$)
Random Social Learning (top), Best Social Learning (bottom)  high $\mu=0.01$ (left), low $\mu = 0.001$ (right)
```{r}
par(mfrow=c(2,2))
plot3Genes(uniquesetupRandomMULT,main="mu=0.01, random copy")
plot3Genes(uniquesetupRandomMuLT,main="mu=0.001, random copy")
plot3Genes(uniquesetupBestMULT,main="mu=0.01, copy the best")
plot3Genes(uniquesetupBestMuLT,main="mu=0.001, copy the best")
```

### High rate of change($vt = 0.2$) 
Random Social Learning (top), Best Social Learning (bottom)  high $\mu=0.01$ (left), low $\mu = 0.001$ (right)
```{r}
par(mfrow=c(2,2))
plot3Genes(uniquesetupRandomMUHT,main="mu=0.01, random copy")
plot3Genes(uniquesetupRandomMuHT,main="mu=0.001, random copy")
plot3Genes(uniquesetupBestMUHT,main="mu=0.01, copy the best")
plot3Genes(uniquesetupBestMuHT,main="mu=0.001, copy the best")
```

## Compare $\omega$, $\delta$, and rate of increase

With $\mu = 0.01$ and $m=.5$

```{r,fig.width=10,fig.height=10}
MMTR=moving_thetaRandom[ moving_thetaRandom$sigma == 1 & moving_thetaRandom$m == .5  & moving_thetaRandom$K == 2000 & moving_thetaRandom$mu == 0.01 ,]
ds=unique(MMTR$delta)
vts=unique(MMTR$vt)
colds=rev(colorRampPalette(c("red","blue"))(length(ds)))
names(colds)=ds
par(mfrow=c(3,3))
for(d in unique(MMTR$omega)){
    for(var in c("mean_z","mean_y","distX")){
        vtDelta=tapply(MMTR[,var][MMTR$omega==d],MMTR[MMTR$omega == d,c("vt","delta")],mean)
        plot(1,1,type="n",main=bquote(omega==.(d)),ylim=range(vtDelta,na.rm=T),xlim=range(vts),xlab="vt",ylab=var)
        for(i in ds)lines(vts,vtDelta[,as.character(i)],col=colds[as.character(i)],lwd=2)
    }
}
legend("topleft",legend=sapply(ds,function(d)as.expression(bquote(delta==.(d)))),lwd=2,lty=1,col=colds)
```

With $\mu = 0.001$ and $m=.2$

```{r,fig.width=10,fig.height=10}
MMTR=moving_thetaRandom[ moving_thetaRandom$sigma == 1 & moving_thetaRandom$m == .2  & moving_thetaRandom$K == 2000 & moving_thetaRandom$mu == 0.001 ,]
ds=unique(MMTR$delta)
vts=unique(MMTR$vt)
colds=colorRampPalette(c("red","blue"))(length(ds))
names(colds)=ds
par(mfrow=c(3,3))
for(d in unique(MMTR$omega)){
    for(var in c("mean_z","mean_y","distX")){
        vtDelta=tapply(MMTR[,var][MMTR$omega==d],MMTR[MMTR$omega == d,c("vt","delta")],mean)
        plot(1,1,type="n",main=bquote(omega==.(d)),ylim=range(vtDelta,na.rm=T),xlim=range(vts),xlab="vt",ylab=var)
        for(i in ds)lines(vts,vtDelta[,as.character(i)],col=colds[as.character(i)],lwd=2)
    }
}
legend("topleft",legend=sapply(ds,function(d)as.expression(bquote(delta==.(d)))),lwd=2,lty=1,col=colds)
```

   



## Different environmental variance

###  Population Size
Check the trajectory of  the effective population size with rate of changes = 0.02 and autocorrelation $\omega = 4$

#### Random Copy
```{r,fig.width=10,fig.height=10}
    plotAllTrajVar(moving_thetaRandom[moving_thetaRandom$vt == 0.02& moving_thetaBest$omega == 4,],m=0.5,E=0,obs="N")
```

#### Copy the Best
```{r,fig.width=10,fig.height=10}
    plotAllTrajVar(moving_thetaBest[moving_thetaBest$vt == 0.02& moving_thetaBest$omega == 4,],m=0.5,E=0,obs="N")
```

### Distance to Optimum
Check the trajectory of the distance to optimum:

#### Random Copy 
```{r,fig.width=10,fig.height=10}
    plotAllTrajVar(moving_thetaRandom[moving_thetaRandom$vt == 0.02& moving_thetaBest$omega == 4,],m=0.5,E=0,obs="dist")
```

#### Copy the Best
```{r,fig.width=10,fig.height=10}
    plotAllTrajVar(moving_thetaBest[moving_thetaBest$vt == 0.02& moving_thetaBest$omega == 4,],m=0.5,E=0,obs="dist")
```

###  Fitness

Check the trajectory of the distance to optimum:

#### Random Copy 
```{r,fig.width=10,fig.height=10}
    plotAllTrajVar(moving_thetaRandom[moving_thetaRandom$vt == 0.02& moving_thetaBest$omega == 4,],m=0.5,E=0,obs="mean_w")
```

#### Copy the Best
```{r,fig.width=10,fig.height=10}
    plotAllTrajVar(moving_thetaBest[moving_thetaBest$vt == 0.02& moving_thetaBest$omega == 4,],m=0.5,E=0,obs="mean_w")
```

## Value at equilibrium

```{r,fig.width=10,fig.height=10}
mtr=moving_thetaRandom[moving_thetaRandom$omega== 4 & moving_thetaRandom$vt== 0.02,]
mtb=moving_thetaBest[moving_thetaBest$omega== 4 & moving_thetaBest$vt== 0.02,]
plotAllVariableSummaries(mtr,E=0,estimate=NULL,var="distX") #we use only simulations without noise
plotAllVariableSummaries(mtr,E=0,estimate=NULL,var="mean_y") #we use only simulations without noise
plotAllVariableSummaries(mtr,E=0,estimate=NULL,var="mean_z") #we use only simulations without noise
plotAllVariableSummaries(mtb,E=0,estimate=NULL,var="distX") #we use only simulations without noise
plotAllVariableSummaries(mtb,E=0,estimate=NULL,var="mean_y") #we use only simulations without noise
plotAllVariableSummaries(mtb,E=0,estimate=NULL,var="mean_z") #we use only simulations without noise
```



## Social Learning vs rates, autocorel and variance:

plot(1,1,ylim=c(0,1))

<!--chapter:end:10_summaryFullGenomes.Rmd-->

# Exploring Sigmas  X and Y


```{r,eval=FALSE}
moving_theta=getAlllSummaries("genetAndILsmall")
moving_theta=updateScale(moving_theta)
save(file="data/moving_thetaGeneIL.bin",moving_theta)
```

```{r}
load(file="data/moving_thetaGeneIL.bin")
```

## Compare final mean value of x and y given $\sigma_s$ and $\sigma_y$
```{r,fig.width=7,fig.height=7}
par(mfrow=c(2,2))
for(m in unique(moving_theta$mu)){
    for(var in c("mean_x","mean_y")){
        uniquesetup=moving_theta[ moving_theta$m == .5 &  moving_theta$K == 2000 & moving_theta$mu == m ,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k))
        colsigmas=colorRampPalette(c("red","blue"))(length(sigmas))
        names(colsigmas)=sigmas
        sigmaK = tapply( uniquesetup[,var],uniquesetup[,c("sigma","k")],mean)
        plot(1,1,type="n",main=bquote(mu==.(m)),ylim=range(sigmaK,na.rm=T),xlab="k",ylab=var,xlim=range(ks))
        for(i in sigmas)lines(ks,sigmaK[as.character(i),],col=colsigmas[as.character(i)],lwd=2,type="b")
        legend("topleft",legend=sapply(sigmas,function(d)as.expression(bquote(sigma[s]==.(d)))),lwd=2,lty=1,col=colsigmas)
    }
}
```



## Mean fitness with and distance to $\theta$

### $\sigma_s > \sigma_y$

Distance to optimum and fitness
```{r}
par(mfrow=c(1,2))
for(m in unique(moving_theta$mu)){
        uniquesetup=moving_theta[ moving_theta$m == .5 &  moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$sigma == 4 & moving_theta$k == .5,]
plotDistVsFitness(uniquesetup,main=bquote(mu==.(m)))
}
```

Mean value of genes and distance between x and optimum

```{r}
par(mfrow=c(1,2))
for(m in unique(moving_theta$mu)){
        uniquesetup=moving_theta[ moving_theta$m == .5 &  moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$sigma == 4 & moving_theta$k == .5,]
plot3Genes(uniquesetup,main=bquote(mu==.(m)))
}
```


### $\sigma_s > \sigma_y$

Distance to optimum and fitness
```{r}
par(mfrow=c(1,2))
for(m in unique(moving_theta$mu)){
        uniquesetup=moving_theta[ moving_theta$m == .5 &  moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$sigma == 4 & moving_theta$k == 2,]
plotDistVsFitness(uniquesetup,main=bquote(mu==.(m)))
}
```

Mean value of genes and distance between x and optimum

```{r}
par(mfrow=c(1,2))
for(m in unique(moving_theta$mu)){
        uniquesetup=moving_theta[ moving_theta$m == .5 &  moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$sigma == 4 & moving_theta$k == 2,]
plot3Genes(uniquesetup,main=bquote(mu==.(m)))
}
```


<!--chapter:end:11_sigmasXY.Rmd-->

# Exploring Sigmas X,Y, and Z Genes


```{r,eval=FALSE}
moving_theta=getAlllSummaries("testSigmas")
moving_theta=updateScale(moving_theta)
moving_theta$distX=abs(moving_theta$theta-moving_theta$mean_x)
save(file="data/moving_thetaXYZ.bin",moving_theta)
```

```{r}
load(file="data/moving_thetaXYZ.bin")
```


## Compare final mean value of x,y and given $\sigma_s$ and $\sigma_y$, Low rate of change ($vt=0.002$), $\omega = 2$ and $m=.2$ and $2\times\sigma_y = \sigma_z$

```{r,fig.width=7,fig.height=7}
par(mfrow=c(2,3))
for(m in unique(moving_theta$mu)){
    for(var in c("distX","mean_y","mean_z")){
        uniquesetup=moving_theta[ moving_theta$m == .2 &  moving_theta$vt == .002 & moving_theta$omega == 2 & moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$k_z==2& moving_theta$delta==.5,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k_y))
        colsigmas=colorRampPalette(c("red","blue"))(length(sigmas))
        names(colsigmas)=sigmas
        sigmaK = tapply( uniquesetup[,var],uniquesetup[,c("sigma","k_y")],mean,na.rm=T)
        plot(1,1,type="n",main=bquote(mu==.(m)),ylim=range(sigmaK,na.rm=T),xlab="k_y",ylab=var,xlim=range(ks))
        for(i in sigmas)lines(ks,sigmaK[as.character(i),],col=colsigmas[as.character(i)],lwd=2,type="b")
        legend("topleft",legend=sapply(sigmas,function(d)as.expression(bquote(sigma[s]==.(d)))),lwd=2,lty=1,col=colsigmas)
    }
}
```

## Compare final mean value of x,y and given $\sigma_s$ and $\sigma_y$, $vt=0.002$ , $\omega = 2$ and $m=.2$ and $8\times\sigma_y = \sigma_z$

```{r,fig.width=7,fig.height=7}
par(mfrow=c(2,3))
for(m in unique(moving_theta$mu)){
    for(var in c("distX","mean_y","mean_z")){
        uniquesetup=moving_theta[ moving_theta$m == .2 &  moving_theta$vt == .002 & moving_theta$omega == 2 & moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$k_z==8 & moving_theta$delta==.5,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k_y))
        colsigmas=colorRampPalette(c("red","blue"))(length(sigmas))
        names(colsigmas)=sigmas
        sigmaK = tapply( uniquesetup[,var],uniquesetup[,c("sigma","k_y")],mean,na.rm=T)
        plot(1,1,type="n",main=bquote(mu==.(m)),ylim=range(sigmaK,na.rm=T),xlab="k_y",ylab=var,xlim=range(ks))
        for(i in sigmas)lines(ks,sigmaK[as.character(i),],col=colsigmas[as.character(i)],lwd=2,type="b")
        legend("topleft",legend=sapply(sigmas,function(d)as.expression(bquote(sigma[s]==.(d)))),lwd=2,lty=1,col=colsigmas)
    }
}
```

## Compare final mean value of x,y and given $\sigma_s$, $\sigma_y$,$\sigma_z$ $vt=0.2$ , $\omega = 2$ and $m=.2$ and $2\times\sigma_y = \sigma_z$

### Low $\delta=.5$

```{r,fig.width=7,fig.height=7}
par(mfrow=c(2,3))
for(m in unique(moving_theta$mu)){
    for(var in c("distX","mean_y","mean_z")){
        uniquesetup=moving_theta[ moving_theta$m == .2 &  moving_theta$vt == .2 & moving_theta$omega == 2 & moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$k_z==2 & moving_theta$delta == .5,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k_y))
        colsigmas=colorRampPalette(c("red","blue"))(length(sigmas))
        names(colsigmas)=sigmas
        sigmaK = tapply( uniquesetup[,var],uniquesetup[,c("sigma","k_y")],mean,na.rm=T)
        plot(1,1,type="n",main=bquote(mu==.(m)),ylim=range(sigmaK,na.rm=T),xlab="k_y",ylab=var,xlim=range(ks))
        for(i in sigmas)lines(ks,sigmaK[as.character(i),],col=colsigmas[as.character(i)],lwd=2,type="b")
        legend("topleft",legend=sapply(sigmas,function(d)as.expression(bquote(sigma[s]==.(d)))),lwd=2,lty=1,col=colsigmas)
    }
}
```

## Compare final mean value of x,y and given $\sigma_s$ and $\sigma_y$, $vt=0.2$ , $\omega = 2$ and $m=.2$ and $8\times\sigma_y = \sigma_z$

### Low $\delta=.5$

```{r,fig.width=7,fig.height=7}
par(mfrow=c(2,3))
for(m in unique(moving_theta$mu)){
    for(var in c("distX","mean_y","mean_z")){
        uniquesetup=moving_theta[ moving_theta$m == .2 &  moving_theta$vt == .2 & moving_theta$omega == 2 & moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$k_z==8 & moving_theta$delta == .5,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k_y))
        colsigmas=colorRampPalette(c("red","blue"))(length(sigmas))
        names(colsigmas)=sigmas
        sigmaK = tapply( uniquesetup[,var],uniquesetup[,c("sigma","k_y")],mean,na.rm=T)
        plot(1,1,type="n",main=bquote(mu==.(m)),ylim=range(sigmaK,na.rm=T),xlab="k_y",ylab=var,xlim=range(ks))
        for(i in sigmas)lines(ks,sigmaK[as.character(i),],col=colsigmas[as.character(i)],lwd=2,type="b")
        legend("topleft",legend=sapply(sigmas,function(d)as.expression(bquote(sigma[s]==.(d)))),lwd=2,lty=1,col=colsigmas)
    }
}
```





## Plot trajectories of the three genes:
### Low rate of change (vt = 0.002) and $\sigma_z = 2\times\sigma_y$
Parameter: m = .2 , vt = .002, omega= 2, K = 2000 delta=.5
```{r,fig.width=10,fig.height=5}
par(mfrow=c(1,3))
for(m in unique(moving_theta$mu)){
    #for(var in c("distX","mean_y","mean_z")){
        uniquesetup=moving_theta[ moving_theta$m == .2 &  moving_theta$vt == .002 & moving_theta$omega == 2 & moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$k_z==2 & moving_theta$delta == .5,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k_y))
        for(i in sigmas){
            for(j in ks){
                plot3Genes(uniquesetup[uniquesetup$sigma==i & uniquesetup$k_y==j,],side="topleft",main=bquote( mu == .(m) ~ k[z] == 2 ~ k[y]== .(j) ~ sigma[s] == .(i)))
            }
        }
    #}
}
```

### High rate of change (vt = 0.2) and $\sigma_z = 2\times\sigma_y$
Parameter: m = .2 , vt = .2, omega= 2, K = 2000 , delta=.5
```{r,fig.width=10,fig.height=5}
par(mfrow=c(1,3))
for(m in unique(moving_theta$mu)){
    #for(var in c("distX","mean_y","mean_z")){
        uniquesetup=moving_theta[ moving_theta$m == .2 &  moving_theta$vt == .2 & moving_theta$omega == 2 & moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$k_z==2 & moving_theta$delta == 2,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k_y))
        for(i in sigmas){
            for(j in ks){
                plot3Genes(uniquesetup[uniquesetup$sigma==i & uniquesetup$k_y==j,],side="topleft",main=bquote( mu == .(m) ~ k[z] == 2 ~ k[y]== .(j) ~ sigma[s] == .(i)))
            }
        }
    #}
}
```


## Plot trajectories of the three genes:
### Low rate of change (vt = 0.002) and $\sigma_z = 2\times\sigma_y$
Parameter: m = .2 , vt = .002, omega= 2, K = 2000 delta=.5
```{r,fig.width=10,fig.height=5}
par(mfrow=c(1,3))
for(m in unique(moving_theta$mu)){
    #for(var in c("distX","mean_y","mean_z")){
        uniquesetup=moving_theta[ moving_theta$m == .2 &  moving_theta$vt == .002 & moving_theta$omega == 2 & moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$k_z==2 & moving_theta$delta == 2,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k_y))
        for(i in sigmas){
            for(j in ks){
                plot3Genes(uniquesetup[uniquesetup$sigma==i & uniquesetup$k_y==j,],side="topleft",main=bquote( mu == .(m) ~ k[z] == 2 ~ k[y]== .(j) ~ sigma[s] == .(i)))
            }
        }
    #}
}
```

### High rate of change (vt = 0.2) and $\sigma_z = 2\times\sigma_y$
Parameter: m = .2 , vt = .2, omega= 2, K = 2000 , delta=.5
```{r,fig.width=10,fig.height=5}
par(mfrow=c(1,3))
for(m in unique(moving_theta$mu)){
    #for(var in c("distX","mean_y","mean_z")){
        uniquesetup=moving_theta[ moving_theta$m == .2 &  moving_theta$vt == .2 & moving_theta$omega == 2 & moving_theta$K == 2000 & moving_theta$mu == m & moving_theta$k_z==2 & moving_theta$delta == .5,]
        sigmas=sort(unique(uniquesetup$sigma))
        ks=sort(unique(uniquesetup$k_y))
        for(i in sigmas){
            for(j in ks){
                plot3Genes(uniquesetup[uniquesetup$sigma==i & uniquesetup$k_y==j,],side="topleft",main=bquote( mu == .(m) ~ k[z] == 2 ~ k[y]== .(j) ~ sigma[s] == .(i)))
            }
        }
    #}
}
```




<!--chapter:end:12_sigmasXYZ.Rmd-->

# Exploring Polymorphism for a few test cases

Exploring single runs and evolution of genomes for all individuals for some given parameters of interest.


```{r,include=F}
library(hdrcde)
color.gradient <- function(x, colors=c("red","yellow","green"), colsteps=100) {
      return( colorRampPalette(colors) (colsteps) [ findInterval(x, seq(min(x),max(x), length.out=colsteps)) ] )
}
load(file="testDistributionsIndividualsWithProp/testDistributionsIndividualsWithProp_abies0/crossExplore.bin")
```

```{r,fig.width=10,fig.height=10,results='asis'}


for( mu in unique(binded$mu)){
    for( v in unique(binded$vt)){
        for( s in unique(binded$sigma)){
            cat(paste0("## With vt = ",v,", $\\sigma = ",s,"$ and $\\mu = ",mu,"$"), sep="\n\r")
            low=binded$filename[ binded$vt == v & binded$sigma == s & binded$mu == mu]
            u=0
            for(i in as.character(low)){
                cat(paste0("Example ",u), sep="\n\r")
                load(file=paste0(i,"pop"))
                fullmat$allpop=fullmat$allpop[2:length(fullmat$allpop)]
                fullmat$allpop=lapply(fullmat$allpop,as.data.frame)
                plotAllVariable(fullmat,hdr=T,vars=c("x","y","z"),fullmat$summary[,"theta"],t=fullmat$summary[,"t"],main=bquote( mu == .(0.01) ~ k[z] == 2 ~ k[y]== 1 ~ sigma[s] == .(4)))
                l=length(fullmat$allpop)
                last=fullmat$allpop[[l]]
                par(mfrow=c(1,1),mar=c(8,8,8,8))
                plot(last[,"y"],last[,"z"],col=alpha(color.gradient(last[,"x"]),.5),ylab="z",xlab="y",ylim=c(0,1),xlim=c(0,1),pch=20,main="genome of last generation",cex=2)
                leg=seq(min(last[,"x"]),max(last[,"x"]),length.out=5)
                legend("bottomleft",
                       legend=round(leg,digit=2),
                       pch=20,
                       col=color.gradient(leg),
                       title="x"
                       )
                u=u+1
            }
            cat("\n\r")
        }
    }
}

```

<!--chapter:end:13_fullgenomeTrajandPolymorphisme.Rmd-->

# (Sexual reproduction) Exploring Polymorphism for a few test cases

Exploring single runs and evolution of genomes for all individuals for some given parameters of interest.


```{r,include=F}
library(hdrcde)
color.gradient <- function(x, colors=c("red","yellow","green"), colsteps=100) {
      return( colorRampPalette(colors) (colsteps) [ findInterval(x, seq(min(x),max(x), length.out=colsteps)) ] )
}
load(file="testFullPopSexualReproCORRRECTED/testFullPopSexualReproCORRRECTED_amd010/crossExplore.bin")
```

```{r,fig.width=10,fig.height=10,results='asis'}


for( mu in unique(binded$mu)){
    for( v in unique(binded$vt)){
        for( s in unique(binded$sigma)){
            cat(paste0("## With vt = ",v,", $\\sigma = ",s,"$ and $\\mu = ",mu,"$"), sep="\n\r")
            low=binded$filename[ binded$vt == v & binded$sigma == s & binded$mu == mu]
            u=0
            for(i in as.character(low)){
                cat(paste0("Example ",u), sep="\n\r")
                load(file=paste0(i,"pop"))
                fullmat$allpop=fullmat$allpop[2:length(fullmat$allpop)]
                fullmat$allpop=lapply(fullmat$allpop,as.data.frame)
                plotAllVariable(fullmat,hdr=T,vars=c("x","y","z"),fullmat$summary[,"theta"],t=fullmat$summary[,"t"],main=bquote( mu == .(0.01) ~ k[z] == 2 ~ k[y]== 1 ~ sigma[s] == .(4)))
                l=length(fullmat$allpop)
                last=fullmat$allpop[[l]]
                par(mfrow=c(1,1),mar=c(8,8,8,8))
                plot(last[,"y"],last[,"z"],col=alpha(color.gradient(last[,"x"]),.6),ylab="z",xlab="y",ylim=c(0,1),xlim=c(0,1),pch=20,main="genome of last generation",cex=2)
                leg=seq(min(last[,"x"]),max(last[,"x"]),length.out=5)
                legend("bottomleft",
                       legend=round(leg,digit=2),
                       pch=20,
                       col=color.gradient(leg),
                       title="x"
                       )
                u=u+1
            }
            cat("\n\r")
        }
    }
}

```

<!--chapter:end:13bis_fullgenomeTrajandPolymorphisme.Rmd-->

# Exploring impact of $k_y$, $k_z$ and $\sigma_s$ on strategies distribution 


```{r,include=F,eval=F}
exploreStrat=getAlllSummaries("test/")
exploreStrat=updateScale(exploreStrat)
save(file="data/exploreStrat.bin",exploreStrat)
```

```{r,include=F}
load("data/exploreStrat.bin")
```

## With Random social Learning

### Trajectories

```{r,fig.width=10,fig.height=10}


    for( v in unique(exploreStrat$vt)){
        low=exploreStrat[ exploreStrat$vt == v & exploreStrat$k_y == .5 & exploreStrat$k_z == 2,]
        plotAllProp(low,m=0.2,E=0)
    }

```

### Final proportions

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStrat$k_y)
kzs=unique(exploreStrat$k_z)
for( mu in unique(exploreStrat$mu)){
    cat(paste0("### Strategies proportion for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2),oma=c(1,1,1,1))
    for( v in unique(exploreStrat$vt)){
        for( sigma in unique(exploreStrat$sigma)){
            subset=exploreStrat[exploreStrat$sigma == sigma & exploreStrat$vt == v & exploreStrat$mu == mu,]

            propy=tapply(subset$prop_y, subset[,c("k_y","k_z")],quantile,na.rm=T)
            propz=tapply(subset$prop_z, subset[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
    #par(mar=c(0,0,0,0))
            plot(1,1,type="n",ylim=c(0,1),xlim=range(kysu,kysu+3*.05),ylab="proportion of population",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                ui=sapply(propy[,kz],"[",2:4)
                uz=sapply(propz[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,ui[1,],kysu+(kz-1)*0.1,ui[3,],col="red",angle=90,code=3,length=.05,lwd=2,lty=kz)
                arrows(kysu+(kz-1)*0.1,uz[1,],kysu+(kz-1)*0.1,uz[3,],col="green",angle=90,code=3,length=.05,lwd=2,lty=kz)
            }
            legend("topright",legend=c(paste("k_z=",kzs),"social","individual"),lty=c(1:3,1,1),col=c(1,1,1,"green","red"))
        }
    }
    cat("\n\r")
}

```

### Fitness wrt. Proportion of Social Learner

```{r}
par(mfrow=c(1,2))
exploreStrat$classZ=cut(exploreStrat$prop_z,breaks=10)
exploreStrat$classY=cut(exploreStrat$prop_y,breaks=10)
boxplot(exploreStrat$mean_w ~ exploreStrat$classY)
boxplot(exploreStrat$mean_w ~ exploreStrat$classZ)

```

### Extinction Time

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStrat$k_y)
kzs=unique(exploreStrat$k_z)
for( mu in unique(exploreStrat$mu)){
    cat(paste0("### Extinction Time for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2))
    for( v in unique(exploreStrat$vt)){
        for( sigma in unique(exploreStrat$sigma)){
            subset=exploreStrat[exploreStrat$sigma == sigma & exploreStrat$vt == v & exploreStrat$mu == mu,]

            exct=tapply(subset$extinction, subset[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
            plot(1,1,type="n",ylim=c(0,40000),xlim=range(kysu,kysu+3*.05),ylab="extinction time",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                et=sapply(exct[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,et[1,],kysu+(kz-1)*0.1,et[3,],angle=90,code=3,length=.05,lwd=3,lty=kz)
            }
            legend("topright",legend=c(paste("k_z=",kzs)),lty=c(1:3),col=c(1,1,1))
        }
    }
    cat("\n\r")
}

```

## With Best social Learning

```{r,include=F,eval=F}
exploreStratBest=getAlllSummaries("bestSLS/")
exploreStratBest=updateScale(exploreStratBest)
save(file="data/exploreStratBest.bin",exploreStratBest)
```

```{r,include=F}
load("data/exploreStratBest.bin")
```

### Trajectories

```{r,fig.width=10,fig.height=10}


    for( v in unique(exploreStratBest$vt)){
        low=exploreStratBest[ exploreStratBest$vt == v & exploreStratBest$k_y == .5 & exploreStratBest$k_z == 2,]
        plotAllProp(low,m=0.2,E=0)
    }

```

### Final proportions

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStratBest$k_y)
kzs=unique(exploreStratBest$k_z)
for( mu in unique(exploreStratBest$mu)){
    cat(paste0("### Strategies proportion for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2))
    for( v in unique(exploreStratBest$vt)){
        for( sigma in unique(exploreStratBest$sigma)){
            subset=exploreStratBest[exploreStratBest$sigma == sigma & exploreStratBest$vt == v & exploreStratBest$mu == mu,]

            propy=tapply(subset$prop_y, subset[,c("k_y","k_z")],quantile,na.rm=T)
            propz=tapply(subset$prop_z, subset[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
            plot(1,1,type="n",ylim=c(0,1),xlim=range(kysu,kysu+3*.05),ylab="proportion of population",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                ui=sapply(propy[,kz],"[",2:4)
                uz=sapply(propz[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,ui[1,],kysu+(kz-1)*0.1,ui[3,],col="red",angle=90,code=3,length=.05,lwd=2,lty=kz)
                arrows(kysu+(kz-1)*0.1,uz[1,],kysu+(kz-1)*0.1,uz[3,],col="green",angle=90,code=3,length=.05,lwd=2,lty=kz)
            }
            legend("topright",legend=c(paste("k_z=",kzs),"social","individual"),lty=c(1:3,1,1),col=c(1,1,1,"green","red"))
        }
    }
    cat("\n\r")
}

```

### Fitness wrt. Proportion of Social Learner

```{r}
par(mfrow=c(1,2))
exploreStratBest$classZ=cut(exploreStratBest$prop_z,breaks=10)
exploreStratBest$classY=cut(exploreStratBest$prop_y,breaks=10)
boxplot(exploreStratBest$mean_w ~ exploreStratBest$classY)
boxplot(exploreStratBest$mean_w ~ exploreStratBest$classZ)

```

### Extinction Time

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStratBest$k_y)
kzs=unique(exploreStratBest$k_z)
for( mu in unique(exploreStratBest$mu)){
    cat(paste0("### Extinction Time for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2))
    for( v in unique(exploreStratBest$vt)){
        for( sigma in unique(exploreStratBest$sigma)){
            subset=exploreStratBest[exploreStratBest$sigma == sigma & exploreStratBest$vt == v & exploreStratBest$mu == mu,]

            exct=tapply(subset$extinction, subset[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
            plot(1,1,type="n",ylim=c(0,40000),xlim=range(kysu,kysu+3*.05),ylab="extinction time",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                et=sapply(exct[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,et[1,],kysu+(kz-1)*0.1,et[3,],angle=90,code=3,length=.05,lwd=3,lty=kz)
            }
            legend("topright",legend=c(paste("k_z=",kzs)),lty=c(1:3),col=c(1,1,1))
        }
    }
    cat("\n\r")
}

```

## Compare Random and Best

### Proportion of Learner vs fitness

```{r}
par(mfrow=c(1,2))
best=tapply(exploreStratBest$mean_w,exploreStratBest$classY,mean)
random=tapply(exploreStrat$mean_w,exploreStrat$classY,mean)
bestsd=tapply(exploreStratBest$mean_w,exploreStratBest$classY,sd)
randomsd=tapply(exploreStrat$mean_w,exploreStrat$classY,sd)
plot(1,1,ylim=c(0,1),xlim=c(1,10),type="n",main="proportion of individual learner",xlab="prop pure Y",ylab="mean w",xaxt="n")
lines(best,col="red",lwd=2)
#lines(best-bestsd,col="red",lty=3)
lines(random,col="black",lwd=2)
#lines(random-randomsd,col="blue",lty=3)
axis(1,at=seq(1,10,length.out=5),label=seq(0,1,length.out=5))
legend("bottomright",legend=c("random","best"),col=c("black","red"),lwd=2)

best=tapply(exploreStratBest$mean_w,exploreStratBest$classZ,mean)
random=tapply(exploreStrat$mean_w,exploreStrat$classZ,mean)
bestsd=tapply(exploreStratBest$mean_w,exploreStratBest$classZ,sd)
randomsd=tapply(exploreStrat$mean_w,exploreStrat$classZ,sd)
plot(1,1,ylim=c(0,1),xlim=c(1,10),type="n",main="proportion of social learner",xlab="prop pure Z",ylab="mean w",xaxt="n")
lines(best,col="red",lwd=2)
#lines(best-bestsd,col="red",lty=3)
lines(random,col="black",lwd=2)
#lines(random-randomsd,col="blue",lty=3)
axis(1,at=seq(1,10,length.out=5),label=seq(0,1,length.out=5))
```


In comparison with [Rogers 1988](https://anthrosource.onlinelibrary.wiley.com/doi/epdf/10.1525/aa.1988.90.4.02a00030), Figure 1:
![roger](images/rogerFig1.png)

### Extinction Time 

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStrat$k_y)
kzs=unique(exploreStrat$k_z)
for( mu in unique(exploreStrat$mu)){
    cat(paste0("### Extinction Time for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2))
    for( v in unique(exploreStrat$vt)){
        for( sigma in unique(exploreStrat$sigma)){
            subset=exploreStrat[exploreStrat$sigma == sigma & exploreStrat$vt == v & exploreStrat$mu == mu,]
            subsetBest=exploreStratBest[exploreStratBest$sigma == sigma & exploreStratBest$vt == v & exploreStratBest$mu == mu,]

            exct=tapply(subset$extinction, subset[,c("k_y","k_z")],quantile,na.rm=T)
            exctBest=tapply(subsetBest$extinction, subsetBest[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
            plot(1,1,type="n",ylim=c(0,40000),xlim=range(kysu,kysu+3*.05),ylab="expression Time",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                et=sapply(exct[,kz],"[",2:4)
                etB=sapply(exctBest[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,et[1,],kysu+(kz-1)*0.1,et[3,],angle=90,code=3,length=.05,lwd=3,lty=kz)
                arrows(kysu+(kz-1)*0.1,etB[1,],kysu+(kz-1)*0.1,etB[3,],angle=90,code=3,length=.05,lwd=3,lty=kz,col="red")
            }
            legend("topright",legend=c(paste("k_z=",kzs),"random","best"),lty=c(1:3,1,1),col=c(1,1,1,1,"red"))
        }
    }
    cat("\n\r")
}

```


<!--chapter:end:14_trackStrat.Rmd-->

# Exploring impact of $k_y$, $k_z$ and $\sigma_s$ on strategies distribution 


```{r,include=F,eval=F}
exploreStrat=getAlllSummaries("ch14SexRepro")
exploreStrat=updateScale(exploreStrat)
save(file="data/exploreStratSex.bin",exploreStrat)
```

```{r,include=F}
load("data/exploreStrat.bin")
```

## With Random social Learning

### Trajectories

```{r,fig.width=10,fig.height=10}


    for( v in unique(exploreStrat$vt)){
        low=exploreStrat[ exploreStrat$vt == v & exploreStrat$k_y == .5 & exploreStrat$k_z == 2,]
        plotAllProp(low,m=0.2,E=0)
    }

```

### Final proportions

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStrat$k_y)
kzs=unique(exploreStrat$k_z)
for( mu in unique(exploreStrat$mu)){
    cat(paste0("### Strategies proportion for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2),oma=c(1,1,1,1))
    for( v in unique(exploreStrat$vt)){
        for( sigma in unique(exploreStrat$sigma)){
            subset=exploreStrat[exploreStrat$sigma == sigma & exploreStrat$vt == v & exploreStrat$mu == mu,]

            propy=tapply(subset$prop_y, subset[,c("k_y","k_z")],quantile,na.rm=T)
            propz=tapply(subset$prop_z, subset[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
    #par(mar=c(0,0,0,0))
            plot(1,1,type="n",ylim=c(0,1),xlim=range(kysu,kysu+3*.05),ylab="proportion of population",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                ui=sapply(propy[,kz],"[",2:4)
                uz=sapply(propz[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,ui[1,],kysu+(kz-1)*0.1,ui[3,],col="red",angle=90,code=3,length=.05,lwd=2,lty=kz)
                arrows(kysu+(kz-1)*0.1,uz[1,],kysu+(kz-1)*0.1,uz[3,],col="green",angle=90,code=3,length=.05,lwd=2,lty=kz)
            }
            legend("topright",legend=c(paste("k_z=",kzs),"social","individual"),lty=c(1:3,1,1),col=c(1,1,1,"green","red"))
        }
    }
    cat("\n\r")
}

```

### Fitness wrt. Proportion of Social Learner

```{r}
par(mfrow=c(1,2))
exploreStrat$classZ=cut(exploreStrat$prop_z,breaks=10)
exploreStrat$classY=cut(exploreStrat$prop_y,breaks=10)
boxplot(exploreStrat$mean_w ~ exploreStrat$classY)
boxplot(exploreStrat$mean_w ~ exploreStrat$classZ)

```

### Extinction Time

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStrat$k_y)
kzs=unique(exploreStrat$k_z)
for( mu in unique(exploreStrat$mu)){
    cat(paste0("### Extinction Time for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2))
    for( v in unique(exploreStrat$vt)){
        for( sigma in unique(exploreStrat$sigma)){
            subset=exploreStrat[exploreStrat$sigma == sigma & exploreStrat$vt == v & exploreStrat$mu == mu,]

            exct=tapply(subset$extinction, subset[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
            plot(1,1,type="n",ylim=c(0,40000),xlim=range(kysu,kysu+3*.05),ylab="extinction time",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                et=sapply(exct[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,et[1,],kysu+(kz-1)*0.1,et[3,],angle=90,code=3,length=.05,lwd=3,lty=kz)
            }
            legend("topright",legend=c(paste("k_z=",kzs)),lty=c(1:3),col=c(1,1,1))
        }
    }
    cat("\n\r")
}

```

## With Best social Learning

```{r,include=F,eval=F}
exploreStratBest=getAlllSummaries("bestSLS/")
exploreStratBest=updateScale(exploreStratBest)
save(file="data/exploreStratBest.bin",exploreStratBest)
```

```{r,include=F}
load("data/exploreStratBest.bin")
```

### Trajectories

```{r,fig.width=10,fig.height=10}


    for( v in unique(exploreStratBest$vt)){
        low=exploreStratBest[ exploreStratBest$vt == v & exploreStratBest$k_y == .5 & exploreStratBest$k_z == 2,]
        plotAllProp(low,m=0.2,E=0)
    }

```

### Final proportions

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStratBest$k_y)
kzs=unique(exploreStratBest$k_z)
for( mu in unique(exploreStratBest$mu)){
    cat(paste0("### Strategies proportion for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2))
    for( v in unique(exploreStratBest$vt)){
        for( sigma in unique(exploreStratBest$sigma)){
            subset=exploreStratBest[exploreStratBest$sigma == sigma & exploreStratBest$vt == v & exploreStratBest$mu == mu,]

            propy=tapply(subset$prop_y, subset[,c("k_y","k_z")],quantile,na.rm=T)
            propz=tapply(subset$prop_z, subset[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
            plot(1,1,type="n",ylim=c(0,1),xlim=range(kysu,kysu+3*.05),ylab="proportion of population",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                ui=sapply(propy[,kz],"[",2:4)
                uz=sapply(propz[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,ui[1,],kysu+(kz-1)*0.1,ui[3,],col="red",angle=90,code=3,length=.05,lwd=2,lty=kz)
                arrows(kysu+(kz-1)*0.1,uz[1,],kysu+(kz-1)*0.1,uz[3,],col="green",angle=90,code=3,length=.05,lwd=2,lty=kz)
            }
            legend("topright",legend=c(paste("k_z=",kzs),"social","individual"),lty=c(1:3,1,1),col=c(1,1,1,"green","red"))
        }
    }
    cat("\n\r")
}

```

### Fitness wrt. Proportion of Social Learner

```{r}
par(mfrow=c(1,2))
exploreStratBest$classZ=cut(exploreStratBest$prop_z,breaks=10)
exploreStratBest$classY=cut(exploreStratBest$prop_y,breaks=10)
boxplot(exploreStratBest$mean_w ~ exploreStratBest$classY)
boxplot(exploreStratBest$mean_w ~ exploreStratBest$classZ)

```

### Extinction Time

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStratBest$k_y)
kzs=unique(exploreStratBest$k_z)
for( mu in unique(exploreStratBest$mu)){
    cat(paste0("### Extinction Time for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2))
    for( v in unique(exploreStratBest$vt)){
        for( sigma in unique(exploreStratBest$sigma)){
            subset=exploreStratBest[exploreStratBest$sigma == sigma & exploreStratBest$vt == v & exploreStratBest$mu == mu,]

            exct=tapply(subset$extinction, subset[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
            plot(1,1,type="n",ylim=c(0,40000),xlim=range(kysu,kysu+3*.05),ylab="extinction time",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                et=sapply(exct[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,et[1,],kysu+(kz-1)*0.1,et[3,],angle=90,code=3,length=.05,lwd=3,lty=kz)
            }
            legend("topright",legend=c(paste("k_z=",kzs)),lty=c(1:3),col=c(1,1,1))
        }
    }
    cat("\n\r")
}

```

## Compare Random and Best

### Proportion of Learner vs fitness

```{r}
par(mfrow=c(1,2))
best=tapply(exploreStratBest$mean_w,exploreStratBest$classY,mean)
random=tapply(exploreStrat$mean_w,exploreStrat$classY,mean)
bestsd=tapply(exploreStratBest$mean_w,exploreStratBest$classY,sd)
randomsd=tapply(exploreStrat$mean_w,exploreStrat$classY,sd)
plot(1,1,ylim=c(0,1),xlim=c(1,10),type="n",main="proportion of individual learner",xlab="prop pure Y",ylab="mean w",xaxt="n")
lines(best,col="red",lwd=2)
#lines(best-bestsd,col="red",lty=3)
lines(random,col="black",lwd=2)
#lines(random-randomsd,col="blue",lty=3)
axis(1,at=seq(1,10,length.out=5),label=seq(0,1,length.out=5))
legend("bottomright",legend=c("random","best"),col=c("black","red"),lwd=2)

best=tapply(exploreStratBest$mean_w,exploreStratBest$classZ,mean)
random=tapply(exploreStrat$mean_w,exploreStrat$classZ,mean)
bestsd=tapply(exploreStratBest$mean_w,exploreStratBest$classZ,sd)
randomsd=tapply(exploreStrat$mean_w,exploreStrat$classZ,sd)
plot(1,1,ylim=c(0,1),xlim=c(1,10),type="n",main="proportion of social learner",xlab="prop pure Z",ylab="mean w",xaxt="n")
lines(best,col="red",lwd=2)
#lines(best-bestsd,col="red",lty=3)
lines(random,col="black",lwd=2)
#lines(random-randomsd,col="blue",lty=3)
axis(1,at=seq(1,10,length.out=5),label=seq(0,1,length.out=5))
```


In comparison with [Rogers 1988](https://anthrosource.onlinelibrary.wiley.com/doi/epdf/10.1525/aa.1988.90.4.02a00030), Figure 1:
![roger](images/rogerFig1.png)

### Extinction Time 

```{r,fig.width=10,fig.height=10,results='asis'}
kys=unique(exploreStrat$k_y)
kzs=unique(exploreStrat$k_z)
for( mu in unique(exploreStrat$mu)){
    cat(paste0("### Extinction Time for mu = ",mu), sep="\n\r")
    par(mfrow=c(2,2))
    for( v in unique(exploreStrat$vt)){
        for( sigma in unique(exploreStrat$sigma)){
            subset=exploreStrat[exploreStrat$sigma == sigma & exploreStrat$vt == v & exploreStrat$mu == mu,]
            subsetBest=exploreStratBest[exploreStratBest$sigma == sigma & exploreStratBest$vt == v & exploreStratBest$mu == mu,]

            exct=tapply(subset$extinction, subset[,c("k_y","k_z")],quantile,na.rm=T)
            exctBest=tapply(subsetBest$extinction, subsetBest[,c("k_y","k_z")],quantile,na.rm=T)
            kysu=1:length(kys)
            plot(1,1,type="n",ylim=c(0,40000),xlim=range(kysu,kysu+3*.05),ylab="expression Time",xlab=expression(k[y]),main=bquote(mu == .(mu) ~ sigma[s] == .(sigma) ~ vt == .(v)  ),xaxt="n")
            axis(1,at=kysu+0.1,label=kys)
            for(kz in 1:length(kzs)){
                et=sapply(exct[,kz],"[",2:4)
                etB=sapply(exctBest[,kz],"[",2:4)
                arrows(kysu+(kz-1)*0.1,et[1,],kysu+(kz-1)*0.1,et[3,],angle=90,code=3,length=.05,lwd=3,lty=kz)
                arrows(kysu+(kz-1)*0.1,etB[1,],kysu+(kz-1)*0.1,etB[3,],angle=90,code=3,length=.05,lwd=3,lty=kz,col="red")
            }
            legend("topright",legend=c(paste("k_z=",kzs),"random","best"),lty=c(1:3,1,1),col=c(1,1,1,1,"red"))
        }
    }
    cat("\n\r")
}

```


<!--chapter:end:14bis_trackStrat.Rmd-->

# Exploring Mixed Strategies (Whitehead 2007)


```{r,fig.width=7,fig.height=7}
load("data/summaryStrategiesRandomParametersWhitehad07.bin")
delta=2^seq(-3,3)
omega=seq(-.5,2.5,.5)
par(mfrow=c(7,7),mar=rep(.1,4),oma=c(6,6,1,1))
na=lapply(summarized,lapply,function(i)pie(i,labels=NA))
par(new=T,mfrow=c(1,1),oma=rep(0,4),mar=c(4,4,1,1))
plot(1,1,ylim=c(0,1),xlim=c(0,1),type="n",xaxt="n",yaxt="n",xlab=expression(omega),ylab=expression(delta))
axis(1,at=seq(0,1,length.out=4),labels=omega[seq(1,7,length.out=4)])
axis(2,at=seq(0,1,length.out=4),labels=delta[seq(1,7,length.out=4)])
```

The pie chart represent the mean percentage over 100 runs of the proportion of the different strategies at the end of the simulation
```{r}
par(mar=rep(0,4))
    pie(c(genetics=.25,individual=.25,vertical=.25,horizontal=.25))
```


Compare to [Whitehead (2007)](https://www.sciencedirect.com/science/article/abs/pii/S0022519306004681) Figure 1 and 2:
![roger](https://ars.els-cdn.com/content/image/1-s2.0-S0022519306004681-gr1.jpg)
![roger](https://ars.els-cdn.com/content/image/1-s2.0-S0022519306004681-gr2.jpg)

<!--chapter:end:15_trackStrat.Rmd-->

